<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigiKipp â€“ KIPP COLOR 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
    }

    #container { 
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 720px;
      overflow: hidden;
      touch-action: none;
    }

    #container canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none;
      user-select: none;
    }

    /* UI OVERLAY */
    #uiOverlay {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 100vh;
      pointer-events: none;
      z-index: 100;
    }

    #hintText {
      position: absolute;
      top: 460px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 36px;
      font-weight: bold;
      color: #d4b48c;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(212,180,140,0.5);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.6));
      pointer-events: none;
      width: 360px;
      overflow: visible;
      line-height: 1.2;
      opacity: 0;
      will-change: transform, opacity, text-shadow;
      backface-visibility: hidden;
      -webkit-font-smoothing: antialiased;
    }
    
    #brainScore {
      position: absolute;
      top: 526px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      width: 360px;
      line-height: 1.2;
      opacity: 0;
      display: none;
    }

    #countdown {
      position: absolute;
      top: 475px;
      left: 180px;
      transform: translateX(-50%);
      font-size: 50px;
      font-weight: bold;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(255,255,255,0.5);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
      pointer-events: none;
      display: none;
    }
    #demoSubtitle {
      position: absolute;
      top: 521px;
      left: 50%;
      transform: translateX(-50%);
      width: 320px;
      text-align: center;
      font-size: 16pt;
      font-weight: bold;
      color: #f0f0f0;
      text-shadow: 0 1px 3px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
      pointer-events: none;
      display: none;
      z-index: 130;
      opacity: 0;
      transition: opacity 0.35s ease;
    }
    #eyeIcon {
      position: absolute;
      top: 475px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: auto;
      cursor: pointer;
      pointer-events: auto;
      filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4));
      display: none;
      z-index: 150;
      animation: eyePulse 1.5s ease-in-out infinite;
    }
    @keyframes eyePulse {
      0%, 100% { transform: translateX(-50%) scale(1); filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4)); }
      50% { transform: translateX(-50%) scale(1.12); filter: drop-shadow(0 2px 12px rgba(255,255,255,0.7)); }
    }
    #kippTarget {
      position: absolute;
      width: 21px;
      height: 21px;
      border: 3px solid #4a2a10;
      border-radius: 50%;
      pointer-events: none;
      display: none;
      z-index: 120;
      transform: translate(-50%, -50%);
      animation: targetPulse 1.5s ease-in-out infinite;
    }
    #kippTarget::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 6px;
      background: #4a2a10;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    @keyframes targetPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
      50% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.5; }
    }
    #entscheidungText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      color: #d4b48c;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      line-height: 1.4;
      text-align: left;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      display: none;
      z-index: 100;
    }
    
    #instructionText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #instructionText .hand-spacer {
      float: left;
      width: 105px;
      height: 46px;
      margin: 0 10px 0 0;
    }
    
    #tutorialText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #spielZielText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #verdecktesKippziel {
      position: absolute;
      width: 45px;
      height: 90px;
      left: 10px;
      top: 481px;
      cursor: pointer;
      z-index: 300;
      animation: pulsate 1.5s ease-in-out infinite;
      transform-origin: center center;
    }
    
    @keyframes pulsate {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.08); }
    }

    #actionButton {
      position: absolute;
      top: 540px;
      left: 180px;
      transform: translateX(-50%);
      padding: 8px 28px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 22px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      pointer-events: auto;
      display: none;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    #actionButton:hover {
      background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%);
      transform: translateX(-50%) translateY(-2px);
    }

    #actionButton:active {
      transform: translateX(-50%) translateY(0);
      background: linear-gradient(180deg, #505050 0%, #303030 100%);
    }

    #actionButton.pulse {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    @keyframes kippPulse {
      0%, 100% { box-shadow: 0 0 4px rgba(212,180,140,0.2); }
      50% { box-shadow: 0 0 10px rgba(212,180,140,0.7), 0 0 22px rgba(212,180,140,0.4); }
    }
    .kippBtn.pulsing {
      animation: kippPulse 1.2s ease-in-out infinite;
    }

    @keyframes textGoldenPulse {
      0%, 100% { 
        transform: translateX(-50%) scale(1);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 10px rgba(212,180,140,0.3);
      }
      50% { 
        transform: translateX(-50%) scale(1.25);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
    }

    @keyframes textSinglePulse {
      0% { 
        opacity: 0;
        transform: translateX(-50%) scale(0.95) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 5px rgba(212,180,140,0.2);
      }
      65% { 
        opacity: 1;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 12px rgba(212,180,140,0.3);
      }
    }


    /* BUTTONS 1-6 */
    #kippButtons {
      position: absolute;
      top: 605px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      pointer-events: auto;
      z-index: 200;
    }

    .kippBtn {
      width: 52px;
      height: 52px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    #cwBtn, #ccwBtn {
      background: linear-gradient(180deg, #404040 0%, #303030 100%);
    }
      background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 50%, #f0f0f0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5),
                  inset 0 1px 0 rgba(255,255,255,0.9);
    }

    .kippBtn:active:not(:disabled) {
      transform: translateY(0);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    .kippBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .kippBtn.running {
      background: linear-gradient(180deg, #ffdd00 0%, #ffcc00 50%, #ffbb00 100%);
      border-color: #cc9900;
    }

    .kippBtn.clicked {
      background: linear-gradient(180deg, #4a3e28 0%, #3a2e1c 100%) !important;
      border-color: #d4b48c !important;
      color: #f0e0c0 !important;
      box-shadow: 0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35), inset 0 0 6px rgba(212,180,140,0.15);
    }

    #resetButton {
      display: none;
      position: absolute;
      width: 90px;
      height: 90px;
      background: transparent;
      border: none;
      cursor: pointer;
      pointer-events: auto;
      z-index: 310;
      padding: 0;
    }

    #resetButton svg {
      display: none;
    }

    #backButton {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      border: 1px solid #c0c0c0;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    #backButton:active {
      transform: scale(0.95);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 1px 2px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    #handIcon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      font-size: 50px;
      pointer-events: none;
      top: 270px;
      display: none;
    }

    .hidden {
      display: none !important;
    }

    /* === START-OVERLAY (transparent, Buttons Ã¼ber 3D-Szene) === */
    #startOverlay {
      position: absolute;
      top: 0;
      width: 360px; height: 720px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 300;
      pointer-events: none;
    }
    .startClickZone {
      position: absolute;
      left: 67px;
      width: 226px;
      height: 42px;
      cursor: pointer;
      pointer-events: auto;
      border: none;
      border-radius: 6px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Arial, sans-serif;
      font-weight: bold;
      font-size: 15px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: #d0d0d0;
      text-shadow: 0 1px 1px rgba(255,255,255,0.4), 0 -1px 1px rgba(0,0,0,0.6);
      overflow: hidden;
      isolation: isolate;
    }
    .startClickZone::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: url('button_lang.webp') center/cover no-repeat;
      opacity: 0.87;
      border-radius: 6px;
      z-index: -1;
    }
    .startClickZone:active {
      filter: brightness(0.85);
    }
    #btnSpielen  { top: 451px; padding-top: 4px; font-size: 18px; letter-spacing: 2.5px; }
    #btnDemo     { top: 519px; padding-top: 4px; font-size: 14px; letter-spacing: 1.5px; }

    /* === ZURUECK-BUTTON (zur Startseite) === */
  </style>
</head>
<body>
  <div id="container"></div>
  
  <!-- START-OVERLAY -->
  <div id="startOverlay">
    <div id="startBackBtn" style="position:absolute; top:0; left:0; width:90px; height:90px; cursor:pointer; pointer-events:auto; z-index:310;"></div>
    <button class="startClickZone" id="btnSpielen" disabled style="opacity:0.4">SPIELEN</button>
    <button class="startClickZone" id="btnDemo" disabled style="opacity:0.4">DEMO</button>
  </div>
  
  <div id="uiOverlay">
    <div id="handIcon">ðŸ‘†</div>
    <div id="hintText"></div>
    <div id="instructionText"></div>
    <img id="verdecktesKippziel" src="leernohit.webp" style="display:none;">
    <div id="tutorialText"></div>
    <div id="spielZielText"></div>
    <div id="entscheidungText"></div>
    <div id="kippTarget"></div>
    <div id="brainScore"></div>
    <div id="countdown">60</div>
    <div id="demoSubtitle"></div>
    <img id="eyeIcon" src="data:image/png;base64,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" />
    <button id="actionButton"></button>
    <button id="backButton">â†»</button>
    <button id="resetButton"><svg viewBox="0 0 24 24" fill="none" stroke="#c0b8a8" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 5l-7 7 7 7"/></svg></button>
    
    <div id="richtungButtons" class="hidden" style="position:absolute;top:540px;left:50%;transform:translateX(-50%);display:flex;gap:21px;width:180px;z-index:200;">
      <button id="cwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†»</span></button>
      <button id="ccwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">â†º</span></button>
    </div>

    <!-- Buttons 1-6 - VernÃ¼nftig positioniert -->
    <div id="kippButtons" class="hidden">
      <button class="kippBtn" data-anzahl="1">1</button>
      <button class="kippBtn" data-anzahl="2">2</button>
      <button class="kippBtn" data-anzahl="3">3</button>
      <button class="kippBtn" data-anzahl="4">4</button>
      <button class="kippBtn" data-anzahl="5">5</button>
      <button class="kippBtn" data-anzahl="6">6</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // === SPRACH-SYSTEM ===
    var _digikippLang = "de";
    try { _digikippLang = localStorage.getItem("digikipp_lang") || "de"; } catch(e) {}
    var T = {
      "de": {
        s1:"SPIEL ZIEL", s2:"\u2022 Finde m\u00f6glichst oft die richtige Kipp-Anzahl und -Richtung heraus, damit der W\u00fcrfel das Kippziel trifft. Hier z.B. <b>{zahl}</b> an <b>{farbe}</b>.<br>Es sind nie mehr als <b>6</b> Kipps, wenn die Richtung stimmt.<br>\u2022 Nutze <b>SCHAU</b>-Sek. effektiv.",
        w:"weiter", n:"Neues Spiel",
        e1:"IMMER 2 OPTIONEN", e2:"Zuerst auf Augen-Icon \u2013 W\u00fcrfelschauen (empfohlen)", e3:"Gleich auf Kippziel \u2013 Kippzug machen",
        k1:"SCHAUEN & MERKEN", k2:"Kippe den W\u00fcrfel in der Box in beliebige Richtung von Ecke zu Ecke. Merke dir m\u00f6glichst viele Zahlenpositionen in m\u00f6glichst kurzer Zeit (Nutze SCHAU-Sek. effektiv).<br>Nach dem SCHAUEN deckst du hier links dein erstes von sechs Kippzielen auf.",
        p1:"TIPPEN & SCHUBSEN", p2:"Das Kippziel links zeigt: <b>{zahl}</b> muss zu <b>{farbe}</b> gekippt werden.<br><b>TIPPE</b> ein- bis sechsmal auf den W\u00fcrfel.<br><b>SCHUBSE</b> ihn anschlie\u00dfend in die gew\u00fcnschte Richtung, um den Kippzug auszul\u00f6sen.",
        bs:"BRAIN SCORE", nh:"No Hit, no Score", st:"{t} HITS | {z} SCHAU-Sekunden", bw:"Best: 100% | Worst: 12%",
        ma:"SPIEL MIT ANLEITUNG", sp:"SPIELEN", dm:"DEMO ANSEHEN",
        d1:["Nach Klick aufs Auge<br>l\u00e4sst sich der W\u00fcrfel","mit dem Finger<br>durch die Box kippen."],
        d1b:["Auf Kante wippen,<br>Zahlenpositionen merken.","Auf Kante wippen,<br>Zahlenpositionen merken.","Der Counter z\u00e4hlt<br>die SCHAU-Sekunden.","Nutze SCHAU-Sek. sparsam,<br>sie verschlechtern deinen","BRAIN SCORE<br>(Endauswertung)."],
        d2:"Klick dir dein KIPP ZIEL.",
        d3:["Das Kippziel zeigt:<br>{z} muss zu {f}.","TIPPE 1 bis 6 mal<br>auf den W\u00fcrfel.","SCHUBSE ihn anschlie\u00dfend<br>in eine beliebige Richtung."],
        d4h:"GETROFFEN!", d4m:"KNAPP DANEBEN!",
        fV:"Violett", fB:"Blau", fG:"Gr\u00fcn", fO:"Orange"
      },
      "en": {
        s1:"OBJECTIVE", s2:"\u2022 Find the right number of tips and the correct direction so the cube hits the target. E.g. <b>{zahl}</b> to <b>{farbe}</b>.<br>It\u2019s never more than <b>6</b> tips if the direction is right.<br>\u2022 Use <b>LOOK</b> seconds efficiently.",
        w:"next", n:"New Game",
        e1:"ALWAYS 2 OPTIONS", e2:"First tap eye icon \u2013 look at the cube (recommended)", e3:"Go straight to target \u2013 make your tipping move",
        k1:"LOOK & REMEMBER", k2:"Tip the cube inside the box in any direction from corner to corner. Memorize as many number positions as possible in the shortest time (Use LOOK seconds efficiently).<br>After LOOKING, uncover your first of six targets here on the left.",
        p1:"TAP & PUSH", p2:"The target on the left shows: <b>{zahl}</b> must reach <b>{farbe}</b>.<br><b>TAP</b> the cube one to six times.<br><b>PUSH</b> it in the desired direction to trigger the tipping move.",
        bs:"BRAIN SCORE", nh:"No Hit, no Score", st:"{t} HITS | {z} LOOK seconds", bw:"Best: 100% | Worst: 12%",
        ma:"PLAY WITH TUTORIAL", sp:"PLAY", dm:"WATCH DEMO",
        d1:["After clicking the eye<br>you can tip the cube","with your finger<br>through the box."],
        d1b:["Tilt to the edge,<br>memorize number positions.","Tilt to the edge,<br>memorize number positions.","The counter counts<br>your LOOK seconds.","Use LOOK sec. sparingly,<br>they worsen your","BRAIN SCORE<br>(final rating)."],
        d2:"Click to reveal your TARGET.",
        d3:["The target shows:<br>{z} must reach {f}.","TAP the cube<br>1 to 6 times.","Then PUSH it<br>in any direction."],
        d4h:"HIT!", d4m:"JUST MISSED!",
        fV:"Violet", fB:"Blue", fG:"Green", fO:"Orange"
      },
      "es": {
        s1:"OBJETIVO", s2:"\u2022 Encuentra el n\u00famero correcto de volcados y la direcci\u00f3n adecuada para que el cubo alcance el objetivo. P.ej. <b>{zahl}</b> a <b>{farbe}</b>.<br>Nunca son m\u00e1s de <b>6</b> volcados si la direcci\u00f3n es correcta.<br>\u2022 Usa los segundos de <b>MIRAR</b> eficientemente.",
        w:"siguiente", n:"Nuevo Juego",
        e1:"SIEMPRE 2 OPCIONES", e2:"Primero pulsa el icono del ojo \u2013 mirar el cubo (recomendado)", e3:"Directo al objetivo \u2013 hacer tu jugada",
        k1:"MIRAR & RECORDAR", k2:"Volca el cubo dentro de la caja en cualquier direcci\u00f3n de esquina a esquina. Memoriza tantas posiciones de n\u00fameros como sea posible en el menor tiempo (Usa los segundos de MIRAR eficientemente).<br>Despu\u00e9s de MIRAR, descubre aqu\u00ed a la izquierda tu primer objetivo de seis.",
        p1:"TOCAR & EMPUJAR", p2:"El objetivo a la izquierda muestra: <b>{zahl}</b> debe llegar a <b>{farbe}</b>.<br><b>TOCA</b> el cubo de una a seis veces.<br><b>EMPUJA</b> en la direcci\u00f3n deseada para activar el volcado.",
        bs:"BRAIN SCORE", nh:"Sin acierto, sin puntos", st:"{t} ACIERTOS | {z} seg. de MIRAR", bw:"Mejor: 100% | Peor: 12%",
        ma:"JUGAR CON GU\u00cdA", sp:"JUGAR", dm:"VER DEMO",
        d1:["Tras pulsar el ojo<br>puedes volcar el cubo","con el dedo<br>por la caja."],
        d1b:["Inclinar al borde,<br>memoriza las posiciones.","Inclinar al borde,<br>memoriza las posiciones.","El contador cuenta<br>tus segundos de MIRAR.","Usa seg. MIRA con cuidado,<br>empeoran tu","BRAIN SCORE<br>(evaluaci\u00f3n final)."],
        d2:"Pulsa para ver tu OBJETIVO.",
        d3:["El objetivo muestra:<br>{z} debe llegar a {f}.","TOCA el cubo<br>de 1 a 6 veces.","Luego EMP\u00daJALO<br>en cualquier direcci\u00f3n."],
        d4h:"\u00a1ACERTADO!", d4m:"\u00a1POR POCO!",
        fV:"Violeta", fB:"Azul", fG:"Verde", fO:"Naranja"
      },
      "fr": {
        s1:"OBJECTIF", s2:"\u2022 Trouve le bon nombre de basculements et la bonne direction pour que le cube atteigne la cible. Par ex. <b>{zahl}</b> \u00e0 <b>{farbe}</b>.<br>Jamais plus de <b>6</b> basculements si la direction est bonne.<br>\u2022 Utilise les secondes de <b>REGARD</b> efficacement.",
        w:"suivant", n:"Nouvelle Partie",
        e1:"TOUJOURS 2 OPTIONS", e2:"D\u2019abord l\u2019ic\u00f4ne \u0153il \u2013 regarder le cube (recommand\u00e9)", e3:"Directement \u00e0 la cible \u2013 faire ton coup",
        k1:"REGARDER & RETENIR", k2:"Bascule le cube dans la bo\u00eete dans n\u2019importe quelle direction de coin en coin. M\u00e9morise autant de positions de chiffres que possible en un minimum de temps (Utilise les secondes de REGARD efficacement).<br>Apr\u00e8s avoir REGARD\u00c9, d\u00e9couvre ici \u00e0 gauche ta premi\u00e8re cible sur six.",
        p1:"TAPER & POUSSER", p2:"La cible \u00e0 gauche indique : <b>{zahl}</b> doit atteindre <b>{farbe}</b>.<br><b>TAPE</b> une \u00e0 six fois sur le cube.<br><b>POUSSE</b>-le dans la direction souhait\u00e9e pour d\u00e9clencher le basculement.",
        bs:"BRAIN SCORE", nh:"Aucun coup, aucun score", st:"{t} COUPS | {z} sec. de REGARD", bw:"Meilleur: 100% | Pire: 12%",
        ma:"JOUER AVEC GUIDE", sp:"JOUER", dm:"VOIR LA D\u00c9MO",
        d1:["Apr\u00e8s clic sur l\u2019\u0153il<br>tu peux basculer le cube","avec le doigt<br>dans la bo\u00eete."],
        d1b:["Basculer sur l\u2019ar\u00eate,<br>m\u00e9morise les positions.","Basculer sur l\u2019ar\u00eate,<br>m\u00e9morise les positions.","Le compteur compte<br>tes secondes de REGARD.","Utilise les sec. REGARD<br>avec parcimonie,","elles d\u00e9gradent ton<br>BRAIN SCORE."],
        d2:"Clique pour r\u00e9v\u00e9ler ta CIBLE.",
        d3:["La cible indique :<br>{z} doit atteindre {f}.","TAPE 1 \u00e0 6 fois<br>sur le cube.","Puis POUSSE-le<br>dans n\u2019importe quelle direction."],
        d4h:"TOUCH\u00c9 !", d4m:"TOUT PR\u00c8S !",
        fV:"Violet", fB:"Bleu", fG:"Vert", fO:"Orange"
      },
      "it": {
        s1:"OBIETTIVO", s2:"\u2022 Trova il numero giusto di ribaltamenti e la direzione corretta affinch\u00e9 il cubo raggiunga il bersaglio. Es. <b>{zahl}</b> a <b>{farbe}</b>.<br>Non sono mai pi\u00f9 di <b>6</b> ribaltamenti se la direzione \u00e8 giusta.<br>\u2022 Usa i secondi di <b>GUARDA</b> in modo efficiente.",
        w:"avanti", n:"Nuova Partita",
        e1:"SEMPRE 2 OPZIONI", e2:"Prima tocca l\u2019icona occhio \u2013 guardare il cubo (consigliato)", e3:"Diretto al bersaglio \u2013 fare la tua mossa",
        k1:"GUARDA & RICORDA", k2:"Ribalta il cubo nella scatola in qualsiasi direzione da angolo ad angolo. Memorizza quante pi\u00f9 posizioni di numeri possibile nel minor tempo (Usa i secondi di GUARDA in modo efficiente).<br>Dopo aver GUARDATO, scopri qui a sinistra il tuo primo bersaglio su sei.",
        p1:"TOCCA & SPINGI", p2:"Il bersaglio a sinistra mostra: <b>{zahl}</b> deve raggiungere <b>{farbe}</b>.<br><b>TOCCA</b> il cubo da una a sei volte.<br><b>SPINGI</b> nella direzione desiderata per attivare il ribaltamento.",
        bs:"BRAIN SCORE", nh:"Nessun colpo, nessun punteggio", st:"{t} COLPI | {z} sec. di GUARDA", bw:"Migliore: 100% | Peggiore: 12%",
        ma:"GIOCA CON GUIDA", sp:"GIOCARE", dm:"GUARDA DEMO",
        d1:["Dopo il clic sull\u2019occhio<br>puoi ribaltare il cubo","con il dito<br>nella scatola."],
        d1b:["Inclinare sul bordo,<br>memorizza le posizioni.","Inclinare sul bordo,<br>memorizza le posizioni.","Il contatore conta<br>i tuoi secondi di GUARDA.","Usa i sec. GUARDA<br>con parsimonia,","peggiorano il tuo<br>BRAIN SCORE."],
        d2:"Clicca per rivelare il BERSAGLIO.",
        d3:["Il bersaglio mostra:<br>{z} deve raggiungere {f}.","TOCCA il cubo<br>da 1 a 6 volte.","Poi SPINGI<br>in qualsiasi direzione."],
        d4h:"COLPITO!", d4m:"QUASI PRESO!",
        fV:"Viola", fB:"Blu", fG:"Verde", fO:"Arancione"
      },
      "tr": {
        s1:"HEDEF", s2:"\u2022 K\u00fcp\u00fcn hedefe ula\u015fmas\u0131 i\u00e7in do\u011fru devrilme say\u0131s\u0131n\u0131 ve y\u00f6n\u00fcn\u00fc bul. \u00d6rn. <b>{zahl}</b> \u2192 <b>{farbe}</b>.<br>Y\u00f6n do\u011fruysa asla <b>6</b>\u2019dan fazla devrilme olmaz.<br>\u2022 <b>BAKMA</b> saniyelerini verimli kullan.",
        w:"devam", n:"Yeni Oyun",
        e1:"HER ZAMAN 2 SE\u00c7ENEK", e2:"\u00d6nce g\u00f6z ikonuna dokun \u2013 k\u00fcpe bak (\u00f6nerilen)", e3:"Do\u011frudan hedefe \u2013 hamle yap",
        k1:"BAK & HATIRLA", k2:"K\u00fcp\u00fc kutunun i\u00e7inde herhangi bir y\u00f6ne k\u00f6\u015feden k\u00f6\u015feye devir. M\u00fcmk\u00fcn oldu\u011funca \u00e7ok say\u0131 pozisyonunu en k\u0131sa s\u00fcrede ezberle (BAKMA saniyelerini verimli kullan).<br>BAKTIKTAN sonra burada solda alt\u0131 hedefinden ilkini a\u00e7.",
        p1:"DOKUN & \u0130T", p2:"Soldaki hedef g\u00f6steriyor: <b>{zahl}</b> \u2192 <b>{farbe}</b> olmal\u0131.<br>K\u00fcpe <b>bir ile alt\u0131</b> kez <b>DOKUN</b>.<br>Sonra istedi\u011fin y\u00f6ne <b>\u0130T</b> ve devrilmeyi ba\u015flat.",
        bs:"BRAIN SCORE", nh:"\u0130sabet yok, puan yok", st:"{t} \u0130SABET | {z} BAKMA saniyesi", bw:"En iyi: 100% | En k\u00f6t\u00fc: 12%",
        ma:"REHBERL\u0130 OYNA", sp:"OYNA", dm:"DEMOYU \u0130ZLE",
        d1:["G\u00f6ze t\u0131klad\u0131ktan sonra<br>k\u00fcp\u00fc parma\u011f\u0131nla","kutuda<br>devrilebilirsin."],
        d1b:["Kenara yat\u0131r,<br>pozisyonlar\u0131 ezberle.","Kenara yat\u0131r,<br>pozisyonlar\u0131 ezberle.","Saya\u00e7 senin<br>BAKMA saniyelerini sayar.","BAKI\u015e saniyelerini<br>az kullan,","BRAIN SCORE\u2019unu<br>k\u00f6t\u00fcle\u015ftirir."],
        d2:"HEDEF\u0130NI a\u00e7mak i\u00e7in t\u0131kla.",
        d3:["Hedef g\u00f6steriyor:<br>{z} \u2192 {f} olmal\u0131.","K\u00fcpe 1\u20136 kez<br>DOKUN.","Sonra \u0130T<br>herhangi bir y\u00f6ne."],
        d4h:"\u0130SABET!", d4m:"AZ KALDI!",
        fV:"Mor", fB:"Mavi", fG:"Ye\u015fil", fO:"Turuncu"
      }
    }[_digikippLang];
    if(!T) T = {s1:"SPIEL ZIEL",s2:"",w:"weiter",n:"Neues Spiel",e1:"IMMER 2 OPTIONEN",e2:"",e3:"",k1:"SCHAUEN & MERKEN",k2:"",p1:"TIPPEN & SCHUBSEN",p2:"",bs:"BRAIN SCORE",nh:"No Hit, no Score",st:"{t} HITS | {z} SCHAU-Sekunden",bw:"Best: 100% | Worst: 12%",ma:"SPIEL MIT ANLEITUNG",sp:"SPIELEN",fV:"Violett",fB:"Blau",fG:"Gr\u00fcn",fO:"Orange"};
    document.getElementById("btnSpielen").textContent = T.sp;
    document.getElementById("btnDemo").textContent = T.dm;

    // =========================
    // Scene Setup
    // =========================
    const scene = new THREE.Scene();
    // scene.background gelÃ¶scht - body background (#000000) wird sichtbar

    const containerWidth = 360;
    const containerHeight = 720;
    
    const camera = new THREE.PerspectiveCamera(
      50,
      containerWidth / containerHeight,
      0.01,
      100
    );
    
    const baseY = 2.143;
    const verticalAngle = -1.0;
    const horizontal = 0;
    const radius = 1.25;
    const southShift = -0.143;
    
    camera.position.set(
      0 + Math.sin(horizontal) * 0.5,
      baseY + radius * Math.sin(-verticalAngle),
      radius * Math.cos(verticalAngle) + Math.cos(horizontal) * 0.3 + southShift
    );
    
    camera.lookAt(0, 0.46875, 0.7 + southShift);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(360, 720);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    document.getElementById('container').appendChild(renderer.domElement);

    // =========================
    // BELEUCHTUNG
    // =========================
    // ZusÃ¤tzliche Pause-Lichter (von allen Seiten, subtil)
    const pauseLights = [
      new THREE.DirectionalLight(0xffffff, 0.25), // links
      new THREE.DirectionalLight(0xffffff, 0.25), // rechts
      new THREE.DirectionalLight(0xffffff, 0.2),  // hinten
      new THREE.DirectionalLight(0xffffff, 0.15)  // unten
    ];
    pauseLights[0].position.set(-3, 2, 1);
    pauseLights[1].position.set(3, 2, 1);
    pauseLights[2].position.set(0, 2, -3);
    pauseLights[3].position.set(0, -1, 2);
    pauseLights.forEach(l => { l.visible = false; scene.add(l); });

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.68);
    mainLight.position.set(0, 8.708, -0.46875);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 20;
    mainLight.shadow.camera.left = -2;
    mainLight.shadow.camera.right = 2;
    mainLight.shadow.camera.top = 2;
    mainLight.shadow.camera.bottom = -2;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
    fillLight.position.set(1, 3, 1);
    scene.add(fillLight);

    const fillLightSouth = new THREE.DirectionalLight(0xffffff, 0.28);
    fillLightSouth.position.set(0, 2, 4);
    scene.add(fillLightSouth);

    // =========================
    // TISCH (Ï€1 Ebene)
    // =========================
    // Boxboden (6x6 Zellen, zentriert um Achsenmittelpunkt)
    const boxbodenTexture = new THREE.TextureLoader().load('Boxboden.webp');
    const boxbodenSize = 6 * 0.15625; // 0.9375
    const boxbodenGeometry = new THREE.PlaneGeometry(boxbodenSize, boxbodenSize);
    const boxbodenMaterial = new THREE.MeshStandardMaterial({ 
      map: boxbodenTexture,
      roughness: 0.8,
      metalness: 0.2
    });
    const boxboden = new THREE.Mesh(boxbodenGeometry, boxbodenMaterial);
    boxboden.rotation.x = -Math.PI / 2;
    boxboden.position.set(0, 0.001, 0.109375);
    boxboden.receiveShadow = true;
    scene.add(boxboden); // ZurÃ¼ck zu scene direkt
    
    const gridSize = 16 * 0.15625;
    const gridDivisions = 16;
    
    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xff8800, 0xff8800);
    gridHelper.position.y = 0.001;
    gridHelper.position.z = 0.421875;
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;
    scene.add(gridHelper);
    
    const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0x888888);
    gridHelper2.position.y = 0.46875;
    gridHelper2.position.z = 0.421875;
    gridHelper2.material.opacity = 0.3;
    gridHelper2.material.transparent = true;
    gridHelper2.visible = false;
    scene.add(gridHelper2);

    // KÃ¤rtchen auf dem Spieltisch (Ï€1, orange Raster)
    const cardWidth = 0.15625;   // 1 Zelle
    const cardHeight = 0.3125;   // 2 Zellen
    const cardGap = (1.25 - 6 * cardWidth) / 5 - 4 * (2.5 / 720); // 6 Karten, Gap -4px
    const cardY = 0.001 + 3 * 0.15625 + 0.002; // auf Spieltisch (3 Zellen Ã¼ber Ï€1)
    const cardZ = 0.109375 + 4 * 0.15625 + 0.15625 + 15 * (2.5 / 720); // 4 Zeilen sÃ¼dlich, + 15px

    const totalCardsWidth = 6 * cardWidth + 5 * cardGap; // TatsÃ¤chliche Breite aller KÃ¤rtchen + Gaps
    const cardStartX = -totalCardsWidth / 2 + cardWidth / 2;

    const gameCards = [];
    
    // Farb-Ziel-Texturen als HTML Images laden
    const colorTargetImages = {};
    const colorTargetTextures = {};
    const imageLoadPromises = [];
    
    const colorNames = ['blau', 'orange', 'gruen', 'violett'];
    colorNames.forEach(name => {
      const promise = new Promise((resolve) => {
        function loadImg(attempt) {
          const img = new Image();
          img.onload = () => {
            colorTargetImages[name] = img;
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            colorTargetTextures[name] = texture;
            console.log(`${name}zielhit.webp loaded`);
            resolve();
          };
          img.onerror = () => {
            console.warn(`${name}zielhit.webp failed (attempt ${attempt}), retrying...`);
            if (attempt < 5) {
              setTimeout(() => loadImg(attempt + 1), 500);
            } else {
              console.error(`${name}zielhit.webp failed after 5 attempts`);
              resolve();
            }
          };
          img.src = `${name}zielhit.webp?v=${attempt}`;
        }
        loadImg(1);
      });
      imageLoadPromises.push(promise);
    });
    
    // Leer-Image laden
    let leerImage = null;
    const leerPromise = new Promise((resolve) => {
      function loadLeer(attempt) {
        const img = new Image();
        img.onload = () => {
          leerImage = img;
          console.log('leernohit.webp loaded');
          resolve();
        };
        img.onerror = () => {
          console.warn(`leernohit.webp failed (attempt ${attempt}), retrying...`);
          if (attempt < 5) {
            setTimeout(() => loadLeer(attempt + 1), 500);
          } else {
            console.error('leernohit.webp failed after 5 attempts');
            resolve();
          }
        };
        img.src = `leernohit.webp?v=${attempt}`;
      }
      loadLeer(1);
    });
    imageLoadPromises.push(leerPromise);
    
    // Warten bis alle Bilder geladen sind
    let texturesReady = false;
    
    Promise.all(imageLoadPromises).then(() => {
      texturesReady = true;
      console.log('All textures ready');
      checkEnableButtons();
    }).catch(() => {
      console.error('Some textures failed to load');
      texturesReady = true;
      checkEnableButtons();
    });
    
    for (let i = 0; i < 6; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = 85;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      // Canvas leer lassen - wird durch fillCard() beim Spielstart gefÃ¼llt

      const texture = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(cardWidth, cardHeight);
      const mat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        side: THREE.DoubleSide 
      });
      const plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.set(cardStartX + i * (cardWidth + cardGap), cardY, cardZ);
      plane.castShadow = true;
      plane.receiveShadow = true;
      scene.add(plane);
      plane.visible = false;

      gameCards.push({ mesh: plane, canvas: canvas, ctx: ctx, texture: texture });
    }
    
    // === Verdecktes Kippziel als 3D-Mesh auf dem Spieltisch (Canvas-basiert) ===
    const verdecktesCanvas = document.createElement('canvas');
    verdecktesCanvas.width = 85;
    verdecktesCanvas.height = 170;
    const verdecktesCtx = verdecktesCanvas.getContext('2d');
    const verdecktesCanvasTex = new THREE.CanvasTexture(verdecktesCanvas);
    
    // leernohit.webp initial draufzeichnen sobald geladen
    function drawLeernohitOnVerdecktes() {
      if (leerImage) {
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(leerImage, 0, 0, 85, 170);
        verdecktesCanvasTex.needsUpdate = true;
      } else {
        setTimeout(drawLeernohitOnVerdecktes, 50);
      }
    }
    drawLeernohitOnVerdecktes();
    
    const verdecktesGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);
    const verdecktesMat = new THREE.MeshBasicMaterial({ 
      map: verdecktesCanvasTex, 
      side: THREE.DoubleSide,
      transparent: true
    });
    const verdecktesMesh = new THREE.Mesh(verdecktesGeo, verdecktesMat);
    verdecktesMesh.rotation.x = -Math.PI / 2;
    verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
    verdecktesMesh.visible = false; // Erst sichtbar wenn Spiel startet
    scene.add(verdecktesMesh);
    
    // Gespeichertes erstes Kippziel
    let erstesKippziel = null;
    
    // === Tap-Counter Anzeige in benachbarten Quadranten ===
    // Benachbarte Quadranten pro WÃ¼rfelposition
    const ADJACENT_Q = { 0: [3, 1], 1: [0, 2], 2: [1, 3], 3: [0, 2] };
    
    const tapIndicatorY = cardY + 0.003;
    const tapIndicatorSize = 0.28;
    
    function createTapIndicator() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const tex = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(tapIndicatorSize, tapIndicatorSize);
      const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.visible = false;
      scene.add(mesh);
      return { mesh, canvas, ctx, tex };
    }
    
    const tapIndicatorA = createTapIndicator();
    const tapIndicatorB = createTapIndicator();
    
    let tapCount = 0;
    
    function drawTapIndicator(indicator, n) {
      const ctx = indicator.ctx;
      ctx.clearRect(0, 0, 128, 128);
      if (n <= 0) { indicator.tex.needsUpdate = true; return; }
      
      // Ã„uÃŸerer Ring mit metallischem Silber
      const grad = ctx.createRadialGradient(64, 64, 30, 64, 64, 56);
      grad.addColorStop(0, 'rgba(200,210,220,0)');
      grad.addColorStop(0.6, 'rgba(180,190,200,0.15)');
      grad.addColorStop(0.85, 'rgba(200,210,220,0.4)');
      grad.addColorStop(1, 'rgba(160,170,180,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 128, 128);
      
      // Zahl mit Silber-Glanz
      ctx.save();
      ctx.font = 'bold 72px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Schatten fÃ¼r Tiefe
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 2;
      
      // Silber-Gradient fÃ¼r die Zahl
      const textGrad = ctx.createLinearGradient(40, 20, 88, 108);
      textGrad.addColorStop(0, '#f0f0f0');
      textGrad.addColorStop(0.3, '#c0c8d0');
      textGrad.addColorStop(0.5, '#e8ecf0');
      textGrad.addColorStop(0.7, '#a8b0b8');
      textGrad.addColorStop(1, '#d0d8e0');
      ctx.fillStyle = textGrad;
      ctx.fillText(n.toString(), 64, 62);
      
      // Glanz-Highlight oben
      ctx.shadowColor = 'transparent';
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffffff';
      ctx.fillText(n.toString(), 64, 60);
      ctx.restore();
      
      indicator.tex.needsUpdate = true;
    }
    
    function updateTapIndicators() {
      const off = 0.234375; // cubeSize/2
      const QC = {
        0: { x: -off, z: 0.109375 - off },
        1: { x:  off, z: 0.109375 - off },
        2: { x:  off, z: 0.109375 + off },
        3: { x: -off, z: 0.109375 + off }
      };
      const adj = ADJACENT_Q[currentQuadrant];
      const qA = QC[adj[0]];
      const qB = QC[adj[1]];
      
      tapIndicatorA.mesh.position.set(qA.x, tapIndicatorY, qA.z);
      tapIndicatorB.mesh.position.set(qB.x, tapIndicatorY, qB.z);
      
      drawTapIndicator(tapIndicatorA, tapCount);
      drawTapIndicator(tapIndicatorB, tapCount);
      
      tapIndicatorA.mesh.visible = tapCount > 0;
      tapIndicatorB.mesh.visible = tapCount > 0;
    }
    // =========================
    // GRADIENT SCHATTEN ÃœBER KÃ„RTCHEN
    // =========================
    // KÃ¤rtchen: X Â±0.625, Z von 0.734375 bis 1.046875
    const shadowGradCanvas = document.createElement('canvas');
    shadowGradCanvas.width = 512;
    shadowGradCanvas.height = 512;
    const sgCtx = shadowGradCanvas.getContext('2d');
    const grad = sgCtx.createLinearGradient(0, 0, 0, 512); // oben nach unten
    grad.addColorStop(0, 'rgba(0, 0, 0, 0.5)');   // Nord: schwarz
    grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)'); // Mitte: transparent
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.0)');   // SÃ¼d: transparent
    sgCtx.fillStyle = grad;
    sgCtx.fillRect(0, 0, 512, 512);

    const shadowGradTexture = new THREE.CanvasTexture(shadowGradCanvas);
    const shadowGradW = 1.25;    // 8 Zellen
    const shadowGradH = 0.3125;  // 2 Zellen = KÃ¤rtchenhÃ¶he
    const shadowGradGeo = new THREE.PlaneGeometry(shadowGradW, shadowGradH);
    const shadowGradMat = new THREE.MeshBasicMaterial({ map: shadowGradTexture, transparent: true });
    const shadowGradPlane = new THREE.Mesh(shadowGradGeo, shadowGradMat);
    shadowGradPlane.rotation.x = -Math.PI / 2;
    shadowGradPlane.position.set(0, 0.001 + 3 * 0.15625 + 0.003, 0.890625); // auf Spieltisch
    shadowGradPlane.visible = false; // Schatten komplett entfernt
    scene.add(shadowGradPlane);


    // =========================
    // ACHSEN (X und Z)
    // =========================
    const axesMaterialPi1 = new THREE.LineBasicMaterial({ 
      color: 0xff8800, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });
    
    const axesMaterial = new THREE.LineBasicMaterial({ 
      color: 0xffffff, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });

    const xAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.002, 0.109375),
      new THREE.Vector3(2.5, 0.002, 0.109375)
    ]);
    const xAxis1 = new THREE.Line(xAxisGeometry1, axesMaterialPi1);
    xAxis1.visible = false;
    scene.add(xAxis1);

    const zAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.002, -2.5),
      new THREE.Vector3(0, 0.002, 2.5)
    ]);
    const zAxis1 = new THREE.Line(zAxisGeometry1, axesMaterialPi1);
    zAxis1.visible = false;
    scene.add(zAxis1);

    const xAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.46875, 0.109375),
      new THREE.Vector3(2.5, 0.46875, 0.109375)
    ]);
    const xAxis2 = new THREE.Line(xAxisGeometry2, axesMaterial);
    xAxis2.visible = false;
    scene.add(xAxis2);

    const zAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.46875, -2.5),
      new THREE.Vector3(0, 0.46875, 2.5)
    ]);
    const zAxis2 = new THREE.Line(zAxisGeometry2, axesMaterial);
    zAxis2.visible = false;
    scene.add(zAxis2);

    // =========================
    // WÃ„NDE mit Metallwand-Textur
    // =========================
    const wallTexture = new THREE.TextureLoader().load('metallwand.webp');
    
    const wallGeometry = new THREE.BoxGeometry(0.9375, 0.46875, 0.0335);
    const wallMaterial = new THREE.MeshBasicMaterial({ 
      map: wallTexture,
      color: 0x666666  // Dunkler (40% Helligkeit)
    });
    
    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
    wall.position.set(0, 0.234375, 0.597125);
    wall.castShadow = false;
    wall.receiveShadow = true;
    scene.add(wall);

    const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
    wall2.position.set(0, 0.234375, -0.376125);
    wall2.castShadow = false;
    wall2.receiveShadow = true;
    scene.add(wall2);

    const sideWallGeometry = new THREE.BoxGeometry(0.0335, 0.46875, 1.00675);
    
    const wallLeft = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallLeft.position.set(-0.48550, 0.234375, 0.1105);
    wallLeft.castShadow = false;
    wallLeft.receiveShadow = true;
    scene.add(wallLeft);
    
    const wallRight = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallRight.position.set(0.48550, 0.234375, 0.1105);
    wallRight.castShadow = false;
    wallRight.receiveShadow = true;
    scene.add(wallRight);

    // =========================
    // SPIELTISCH TEXTUR (ersetzt codierten Rahmen)
    // =========================
    let spieltisch = null;
    const SPIEL_WIDTH = 8 * 0.15625;
    
    new THREE.TextureLoader().load('spieltisch.webp', (texture) => {
      const imgAspect = texture.image.height / texture.image.width;
      const height = SPIEL_WIDTH * imgAspect;
      
      const spieltischGeometry = new THREE.PlaneGeometry(SPIEL_WIDTH, height);
      const spieltischMaterial = new THREE.MeshStandardMaterial({ 
        map: texture,
        transparent: true,
        roughness: 0.8,
        metalness: 0.2,
        depthWrite: true
      });
      spieltisch = new THREE.Mesh(spieltischGeometry, spieltischMaterial);
      
      spieltisch.rotation.x = -Math.PI / 2;
      
      // Position ABSOLUT FINAL
      const xCenter = -0.625 + SPIEL_WIDTH / 2;
      const zCenter = -0.828125 + height / 2;
      const yPos = 0.001 + 3 * 0.15625;
      
      spieltisch.position.set(xCenter, yPos, zCenter);
      spieltisch.receiveShadow = false;
      spieltisch.castShadow = false;
      spieltisch.renderOrder = 1;
      
      // Matrix komplett einfrieren
      spieltisch.matrixAutoUpdate = false;
      spieltisch.updateMatrix();
      
      // Direkt zu Scene hinzufÃ¼gen
      scene.add(spieltisch);
      console.log('Spieltisch loaded at fixed position:', xCenter, yPos, zCenter);
    });

    // =========================
    // HAND-DEMO fÃ¼r Phase 1
    // =========================
    const handTexture = new THREE.TextureLoader().load('data:image/png;base64,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');
    const handWidth = 0.46875; // 3 Zellen (75% von 4x)
    const handGeometry = new THREE.PlaneGeometry(handWidth, handWidth);
    const handMaterial = new THREE.MeshBasicMaterial({ 
      map: handTexture,
      transparent: true,
      side: THREE.DoubleSide,
      alphaTest: 0.1
    });
    const handDemo = new THREE.Mesh(handGeometry, handMaterial);
    handDemo.rotation.x = -Math.PI / 2;
    // Position: Zeile 11 Oberlinie, Spalte A Mitte
    // Zeile 11 Oberlinie: -0.359375 + 7 * 0.15625 - 0.078125 = 0.656250
    handDemo.position.set(-0.625 + handWidth/2 + 0.15625, 0.001 + 3 * 0.15625 + 0.15, 0.656250 + 0.15625);
    const handOriginalPos = handDemo.position.clone(); // Ursprungsposition speichern
    handDemo.visible = false;
    scene.add(handDemo);

    // =========================
    // WÃœRFEL mit 3x3 Grid-Textur
    // =========================
    // WÃ¼rfel-Textur WebP (fÃ¼r f0, f1, f2)
    const cubeTexImg = new Image();
    cubeTexImg.src = 'data:image/webp;base64,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';
    
    // Leere WÃ¼rfelflÃ¤chen-Textur wird weiter unten als Base64 geladen
    cubeTexImg.src = 'data:image/webp;base64,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';
    const cubeSize = 0.46875;

    // Randomdeck 1-12 mischen
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    const deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);

    // Slot-Zuordnung: welche Zelle auf welcher Face â†’ deck-Index
    // f0: 7=S1, 4=S2, 2=S3, 3=S4
    // f1: 10=S1, 11=S2, 15=S3, 18=S4
    // f2: 27=S1, 26=S2, 22=S3, 19=S4
    // deck[0-3] â†’ f0 Slots, deck[4-7] â†’ f1 Slots, deck[8-11] â†’ f2 Slots

    // Canvas-Textur: 3x3 Gitter, slotMap = { "row,col": { val, rot } }
    function createFaceTexture(slotMap, imgRotation, numberAlpha) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const cell = 256 / 3;

      // WÃ¼rfel-Textur als Hintergrund (optional rotiert, SÃ¤ttigung reduziert)
      ctx.save();
      ctx.translate(128, 128);
      if (imgRotation) ctx.rotate(imgRotation);
      ctx.drawImage(cubeTexImg, -128, -128, 256, 256);
      ctx.restore();
      
      // Kontrast reduzieren mit semi-transparentem Overlay
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fillRect(0, 0, 256, 256);

      // Slot-Zellen beschriften
      const alpha = (numberAlpha !== undefined) ? numberAlpha : 1;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#2a1810';
      ctx.font = 'bold 56px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const key in slotMap) {
        const [r, c] = key.split(',').map(Number);
        const { val, rot } = slotMap[key];
        const cx = c * cell + cell / 2;
        const cy = r * cell + cell / 2;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        // Zweistellige Zahlen leicht nach links fÃ¼r optische Zentrierung
        const xOff = val >= 10 ? -4 : 0;
        ctx.fillText(val.toString(), xOff, 0);
        // Punkt bei 6 und 9: Satzpunkt nach der Zahl, gleiche Baseline
        if (val === 6 || val === 9) {
          ctx.beginPath();
          ctx.arc(xOff + 22, 18, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Rand
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#6b5040';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, 250, 250);

      return canvas;
    }

    function mat(slotMap, imgRotation, numberAlpha) {
      return new THREE.MeshStandardMaterial({
        map: new THREE.CanvasTexture(createFaceTexture(slotMap || {}, imgRotation, numberAlpha)),
        metalness: 0.3, roughness: 0.7
      });
    }

    // Leere WÃ¼rfelflÃ¤chen-Textur (Base64 embedded)
    const leereWflTexture = new THREE.TextureLoader().load('data:image/webp;base64,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');
    function matLeer() {
      return new THREE.MeshStandardMaterial({
        map: leereWflTexture,
        metalness: 0.3, roughness: 0.7
      });
    }

    // Material-Array: [+X, -X, +Y, -Y, +Z, -Z]
    // Rotationen per-Slot:
    // f2 (+Y): S1,S2 von SÃ¼den lesbar (0), S3,S4 von Westen lesbar (-Ï€/2)
    // f0 (+Z): S1,S2 von Westen lesbar (-Ï€/2), S3,S4 stehen Kopf (Ï€)
    // f1 (-X): S1,S2 stehen Kopf (Ï€), S3,S4 von SÃ¼den lesbar (Ï€/2)
    let cubeMaterial = [];
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const offset = cubeSize / 2;

    // =========================
    // KANTEN-KIPP-WÃœRFEL
    // =========================
    const kipGroup = new THREE.Group();
    kipGroup.visible = true;
    scene.add(kipGroup);
    
    const cube = new THREE.Mesh(cubeGeometry, []);
    cube.position.set(-offset, offset, 0.109375 + offset);
    cube.castShadow = true;
    cube.receiveShadow = true;
    kipGroup.add(cube);

    // Face-Definitionen fÃ¼r Rebuild mit variablem Alpha
    const faceSlots = {
      f1: {
        slotMap: { '0,0': { val: deck[4], rot: Math.PI }, '0,1': { val: deck[5], rot: Math.PI }, '1,2': { val: deck[6], rot: -Math.PI/2 }, '2,2': { val: deck[7], rot: -Math.PI/2 } },
        imgRot: Math.PI/2, matIdx: 1
      },
      f2: {
        slotMap: { '2,2': { val: deck[8], rot: 0 }, '2,1': { val: deck[9], rot: 0 }, '1,0': { val: deck[10], rot: Math.PI/2 }, '0,0': { val: deck[11], rot: Math.PI/2 } },
        imgRot: -Math.PI/2, matIdx: 2
      },
      f0: {
        slotMap: { '2,0': { val: deck[0], rot: Math.PI/2 }, '1,0': { val: deck[1], rot: Math.PI/2 }, '0,1': { val: deck[2], rot: Math.PI }, '0,2': { val: deck[3], rot: Math.PI } },
        imgRot: 0, matIdx: 4
      }
    };

    function rebuildFaceMat(faceKey, alpha) {
      const f = faceSlots[faceKey];
      const newMat = mat(f.slotMap, f.imgRot, alpha);
      cubeMaterial[f.matIdx] = newMat;
      cube.material = cubeMaterial;
    }

    // Materialien erst wenn Textur-Image geladen
    cubeTexImg.onload = function() {
      // Start mit unsichtbaren Zahlen (alpha=0)
      cubeMaterial = [
        matLeer(),                                    // [0] +X
        mat(faceSlots.f1.slotMap, faceSlots.f1.imgRot, 0), // [1] -X = f1
        mat(faceSlots.f2.slotMap, faceSlots.f2.imgRot, 0), // [2] +Y = f2
        matLeer(),                                    // [3] -Y
        mat(faceSlots.f0.slotMap, faceSlots.f0.imgRot, 0), // [4] +Z = f0
        matLeer()                                     // [5] -Z
      ];
      cube.material = cubeMaterial;
      
      // === LOADING ANIMATION ===
      runLoadingAnimation();
    };

    // Kipp-Hilfsfunktion fÃ¼r Loading-Animation (leichtgewichtig, ohne Spiellogik)
    function loadingKipp(direction, duration) {
      return new Promise(resolve => {
        const pivotDefs = {
          'north':         { pivot: [-offset, 0, 0.109375],        axis: [1,0,0], angle: -Math.PI/2 },
          'east':          { pivot: [0, 0, 0.109375 + cubeSize],   axis: [0,0,1], angle: -Math.PI/2 },
          'south_from_q1': { pivot: [offset, 0, 0.109375],         axis: [1,0,0], angle: Math.PI/2 },
          'west_from_q2':  { pivot: [0, 0, 0.109375 + cubeSize],   axis: [0,0,1], angle: Math.PI/2 }
        };
        const def = pivotDefs[direction];
        const pivotPoint = new THREE.Vector3(def.pivot[0], def.pivot[1], def.pivot[2]);
        const rotAxis = new THREE.Vector3(def.axis[0], def.axis[1], def.axis[2]);
        
        const pivotGroup = new THREE.Group();
        pivotGroup.position.copy(pivotPoint);
        scene.add(pivotGroup);
        
        kipGroup.remove(cube);
        cube.position.sub(pivotPoint);
        pivotGroup.add(cube);
        
        const startTime = performance.now();
        function animateKipp() {
          const elapsed = performance.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
          
          pivotGroup.quaternion.setFromAxisAngle(rotAxis, def.angle * ease);
          
          if (t < 1) {
            requestAnimationFrame(animateKipp);
          } else {
            pivotGroup.quaternion.setFromAxisAngle(rotAxis, def.angle);
            cube.position.applyQuaternion(pivotGroup.quaternion);
            cube.quaternion.premultiply(pivotGroup.quaternion);
            cube.position.add(pivotPoint);
            // Snap Y
            cube.position.y = Math.round(cube.position.y * 1000) / 1000;
            if (Math.abs(cube.position.y - offset) < 0.01) cube.position.y = offset;
            
            pivotGroup.remove(cube);
            kipGroup.add(cube);
            scene.remove(pivotGroup);
            resolve();
          }
        }
        requestAnimationFrame(animateKipp);
      });
    }

    function fadeInFace(faceKey, duration) {
      return new Promise(resolve => {
        const startTime = performance.now();
        function step() {
          const t = Math.min((performance.now() - startTime) / duration, 1);
          rebuildFaceMat(faceKey, t);
          if (t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    let loadingAnimDone = false;

    async function runLoadingAnimation() {
      const kd = 350; // Kipp-Dauer ms
      const fd = 500; // Fade-Dauer ms

      // CW-Zyklus: Q3â†’Q0â†’Q1â†’Q2â†’Q3...
      const cwDirs = ['north', 'east', 'south_from_q1', 'west_from_q2'];

      // 1) f2 obenauf in Q3 â€“ Zahlen einfaden
      await fadeInFace('f2', fd);
      await new Promise(r => setTimeout(r, 200));

      // 2) Kipp 1 â†’ Q0, f0 obenauf â€“ einfaden
      await loadingKipp('north', kd);
      await fadeInFace('f0', fd);
      await new Promise(r => setTimeout(r, 200));

      // 3) Kipp 2 â†’ Q1, f1 obenauf â€“ einfaden
      await loadingKipp('east', kd);
      await fadeInFace('f1', fd);
      await new Promise(r => setTimeout(r, 200));

      // 4) Kipps 3-12 zurÃ¼ck nach Q3 (10 weitere Kipps im CW-Zyklus)
      // Kontinuierlich schneller werdend: 350ms â†’ 120ms
      const remaining = ['south_from_q1','west_from_q2','north','east','south_from_q1','west_from_q2','north','east','south_from_q1','west_from_q2'];
      for (let ri = 0; ri < remaining.length; ri++) {
        const t = ri / (remaining.length - 1); // 0 â†’ 1
        const kipDur = Math.round(350 - 230 * t); // 350 â†’ 120
        const pauseDur = Math.round(80 - 60 * t); // 80 â†’ 20
        await loadingKipp(remaining[ri], kipDur);
        await new Promise(r => setTimeout(r, pauseDur));
      }

      // Sicherstellen: WÃ¼rfel liegt exakt in Q3, f2 obenauf
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      // Alle Faces auf volle Sichtbarkeit
      rebuildFaceMat('f0', 1);
      rebuildFaceMat('f1', 1);
      rebuildFaceMat('f2', 1);

      loadingAnimDone = true;
      checkEnableButtons();
    }

    function checkEnableButtons() {
      if (texturesReady && loadingAnimDone) {
        document.getElementById('btnSpielen').disabled = false;
        document.getElementById('btnSpielen').style.opacity = '1';
        document.getElementById('btnDemo').disabled = false;
        document.getElementById('btnDemo').style.opacity = '1';
        actionButton.disabled = false;
      }
    }

    // =========================
    // 2D-TIMING SYSTEM
    // =========================
    const FIXED_SPEED = 3;
    const TARGET_MIN = 0.55;
    const STEP_MAX = 0.80;
    let targetTimeMul = 1;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function getTiming() {
      const v = FIXED_SPEED;
      const baseHold = Math.max(520, Math.round(2400 - v * 450));
      const baseKip = Math.max(160, Math.round(baseHold * 0.50));
      const baseW = baseHold;
      
      const mul = Math.max(TARGET_MIN, Math.min(1, targetTimeMul));
      
      const hold = Math.max(260, Math.round(baseHold * mul));
      const kip = Math.max(120, Math.round(baseKip * mul));
      const wfull = Math.max(260, Math.round(baseW * mul));
      
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    // =========================
    // UI ELEMENTS
    // =========================
    const hintText = document.getElementById('hintText');
    const countdown = document.getElementById('countdown');
    const actionButton = document.getElementById('actionButton');
    const backButton = document.getElementById('backButton');
    const resetButton = document.getElementById('resetButton');
    const kippButtons = document.getElementById('kippButtons');
    
    // WICHTIG: Button disabled bis Texturen geladen sind
    actionButton.disabled = true;

    // =========================
    // SPIELLOGIK: Treffer-PrÃ¼fung
    // =========================
    let topFace = 'f2'; // Anfangslage beim Spieleintritt

    function advanceTopFace() {
      const cw  = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccw = { f2: 'f1', f1: 'f0', f0: 'f2' };
      const oldFace = topFace;
      topFace = (kippDirection === 'cw') ? cw[topFace] : ccw[topFace];
      console.log('advanceTopFace:', oldFace, 'â†’', topFace, 'dir:', kippDirection, 'Q:', currentQuadrant);
    }

    // Welche Nachbarfarbe hat jeder Slot pro Quadrant
    const SLOT_NEIGHBOR_COLORS = {
      0: { S1: 'blau',    S2: 'violett', S3: 'gruen',   S4: 'orange'  },
      1: { S1: 'orange',  S2: 'blau',    S3: 'violett', S4: 'gruen'   },
      2: { S1: 'gruen',   S2: 'orange',  S3: 'blau',    S4: 'violett' },
      3: { S1: 'violett', S2: 'gruen',   S3: 'orange',  S4: 'blau'    }
    };

    // Zielkreis-Positionen pro Quadrant (3D-Koordinaten)
    const KIPP_TARGET_POS_3D = {
      0: new THREE.Vector3(-0.15625, 0.48, -0.046875),  // Q0 NW: Zeilen 5/6, Spalten C/D
      1: new THREE.Vector3( 0.15625, 0.48, -0.046875),  // Q1 NE: Zeilen 5/6, Spalten E/F
      2: new THREE.Vector3( 0.15625, 0.48,  0.265625),  // Q2 SE: Zeilen 7/8, Spalten E/F
      3: new THREE.Vector3(-0.15625, 0.48,  0.265625)   // Q3 SW: Zeilen 7/8, Spalten C/D
    };

    function updateKippTargetPosition() {
      const pos3D = KIPP_TARGET_POS_3D[currentQuadrant].clone();
      pos3D.project(camera);
      const targetEl = document.getElementById('kippTarget');
      targetEl.style.left = ((pos3D.x * 0.5 + 0.5) * 360) + 'px';
      targetEl.style.top = ((-pos3D.y * 0.5 + 0.5) * 720) + 'px';
    }

    // 4 Farbfelder pro Quadrant (fÃ¼r Nicht-Treffer-Animation)
    const QUADRANT_COLORS = {
      0: ['Nord_C', 'Nord_D', 'West_5', 'West_6'],
      1: ['Nord_E', 'Nord_F', 'Ost_5',  'Ost_6'],
      2: ['SÃ¼d_E',  'SÃ¼d_F',  'Ost_7',  'Ost_8'],
      3: ['SÃ¼d_C',  'SÃ¼d_D',  'West_7', 'West_8']
    };

    // Material-Index pro Face (BoxGeometry: [+X,-X,+Y,-Y,+Z,-Z])
    const TOP_FACE_MAT_IDX = { f0: 4, f1: 1, f2: 2 };

    // DesÃ¤tturierte Versionen der Spielfarben fÃ¼r das KÃ¤rtchen
    const DESAT_COLORS = {
      violett: '#6b5a6b',
      blau:    '#5a6b7b',
      gruen:   '#5b7b6b',
      orange:  '#7b6b5a'
    };

    function checkTreffer() {
      const card = gameCards[activeCardIdx];
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };

      // Ist card.zahl sichtbar?
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === card.zahl) { hitSlot = slot; break; }
      }
      if (!hitSlot) return false;

      // Nachbarfarbe prÃ¼fen
      const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
      return neighborColor === card.color.name;
    }

    // Generische Animation eines Wertes Ã¼ber Zeit
    function animateVal(from, to, duration, onUpdate, onFinish) {
      const start = performance.now();
      function tick(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
        onUpdate(from + (to - from) * eased);
        if (t < 1) requestAnimationFrame(tick);
        else if (onFinish) onFinish();
      }
      requestAnimationFrame(tick);
    }

    let activeCardIdx = 0;
    const bereitsGetroffen = new Set(); // "zahl_farbe" Kombinationen die bereits Treffer waren
    const bereitsAusgegeben = new Set(); // "zahl_farbe" Kombinationen die bereits als Ziel ausgegeben wurden
    
    const GAME_COLORS = [
      { name: 'violett', hex: '#a41b85' },
      { name: 'blau',    hex: '#006bb3' },
      { name: 'gruen',   hex: '#00a652' },
      { name: 'orange',  hex: '#e67814' }
    ];

    // === Offene Kippziele: genau 2 von 6 haben eine Zahl, die in der aktuellen Ausgangslage sichtbar ist ===
    function pickTwoRandomPositions() {
      const all = [0, 1, 2, 3, 4, 5];
      for (let i = all.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [all[i], all[j]] = [all[j], all[i]];
      }
      return new Set([all[0], all[1]]);
    }
    let openKippzielPositions = pickTwoRandomPositions();
    let offeneKippzieleVergeben = 0; // ZÃ¤hlt wie viele offene bereits generiert wurden
    let isReplay = false; // Nach "Neues Spiel" â†’ kein ErklÃ¤rtext

    // Aktuell sichtbare Zahlen auf der Oberseite ermitteln (aus aktuellem topFace)
    function getCurrentVisibleZahlen() {
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      return new Set([deck[off], deck[off+1], deck[off+2], deck[off+3]]);
    }

    function fillCardWithKombi(idx, zahl, colorObj) {
      const card = gameCards[idx];
      
      // Zahl und Farbe im Card-Object speichern
      card.zahl = zahl;
      card.color = colorObj;
      
      // Farb-Image auf Canvas zeichnen
      const img = colorTargetImages[colorObj.name];
      if (!img) {
        console.error(`Image ${colorObj.name} not loaded!`);
        return;
      }
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      // Zahl 42px unter Oberkante
      const displayText = zahl + ((zahl === 6 || zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.visible = true; // KÃ¤rtchen sichtbar machen
      
      // Kombi als ausgegeben markieren
      bereitsAusgegeben.add(zahl + '_' + colorObj.name);
    }
    
    function drawGoldenBorder(card) {
      // CMYK: 18, 20, 85, 3 â†’ RGB: #cedb25
      card.ctx.strokeStyle = '#cedb25';
      card.ctx.lineWidth = 4;
      card.ctx.strokeRect(2, 2, 85 - 4, 170 - 4);
      card.texture.needsUpdate = true;
      
      // Markieren dass dieses KÃ¤rtchen ein Treffer ist
      card.isHit = true;
    }
    

    function generateNeueKombiOhne(ausschlussSet, zahlenFilter, visibleZahlen) {
      // zahlenFilter: 'open' = nur sichtbare Zahlen, 'closed' = nur NICHT sichtbare, undefined = alle
      // visibleZahlen: Set der aktuell sichtbaren Zahlen (nur nÃ¶tig wenn zahlenFilter gesetzt)
      const alleMoeglichenKombis = [];
      for (let z = 1; z <= 12; z++) {
        if (zahlenFilter === 'open' && visibleZahlen && !visibleZahlen.has(z)) continue;
        if (zahlenFilter === 'closed' && visibleZahlen && visibleZahlen.has(z)) continue;
        
        for (const colorObj of GAME_COLORS) {
          const key = z + '_' + colorObj.name;
          if (!bereitsAusgegeben.has(key) && !ausschlussSet.has(key)) {
            alleMoeglichenKombis.push({ zahl: z, color: colorObj });
          }
        }
      }
      
      if (alleMoeglichenKombis.length === 0) return null;
      
      const idx = Math.floor(Math.random() * alleMoeglichenKombis.length);
      return alleMoeglichenKombis[idx];
    }

    function getCurrentErfuellteKombis() {
      // Aktuelle WÃ¼rfellage ermitteln und erfÃ¼llte Kombis zurÃ¼ckgeben
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const erfuellteKombis = new Set();
      const slots = ['S1', 'S2', 'S3', 'S4'];
      slots.forEach((slot, i) => {
        const zahl = deck[off + i];
        const farbe = SLOT_NEIGHBOR_COLORS[currentQuadrant][slot];
        erfuellteKombis.add(zahl + '_' + farbe);
      });
      return erfuellteKombis;
    }


    function onRunde() {
      activeCardIdx++;
      
      // Nach 6 Versuchen: Spielende
      if (activeCardIdx >= 6) {
        showGameEnd();
        return;
      }
      
      // ERST: NEUES KÃ„RTCHEN GENERIEREN
      if (activeCardIdx < 6) {
        const erfuellteKombis = getCurrentErfuellteKombis();
        const visibleZahlen = getCurrentVisibleZahlen();
        let zahlenFilter;
        if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
          zahlenFilter = 'open';
        } else {
          zahlenFilter = 'closed';
        }
        let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
        if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis); // Fallback
        if (neueKombi) {
          if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
          fillCardWithKombi(activeCardIdx, neueKombi.zahl, neueKombi.color);
        }
      }
      
      // DANN: Pause-Check (ÃœBERSPRUNGEN - Pause-Phase deaktiviert)
      // if (activeCardIdx === 3) {
      //   setButtonsDisabled(true);
      //   document.getElementById('richtungButtons').classList.add('hidden');
      //   kippButtons.classList.add('hidden');
      //   savedCubePosition = cube.position.clone();
      //   savedCubeQuaternion = cube.quaternion.clone();
      //   savedTopFace = topFace;
      //   savedCurrentQuadrant = currentQuadrant;
      //   animateAufEcke().then(() => {
      //     startPausePhase();
      //   });
      //   return;
      // }
      
      // Weiterspielen
      setButtonsDisabled(false);
    }
    
    function calculateBrainScore(observationTime, hits) {
      // Constants
      const FREE_TIME = 20;
      const MAX_TIME = 120;
      const EXTRA_TIME_RANGE = 100; // MAX_TIME - FREE_TIME
      const k = 1.0;
      const c = 2.5976583;
      
      // Special case: no hits
      if (hits === 0) {
        return "No Hit, no Score";
      }
      
      // Clamp observation time
      let T = observationTime;
      if (T < FREE_TIME) T = FREE_TIME;
      if (T > MAX_TIME) T = MAX_TIME;
      
      // Time Factor
      const E = Math.max(0, Math.min(T - FREE_TIME, EXTRA_TIME_RANGE));
      const S_time = 1 - 0.31 * Math.pow(E / EXTRA_TIME_RANGE, 0.855);
      
      // Hit Factor (logistic)
      const L = (H) => 1 / (1 + Math.exp(-k * (H - c)));
      const S_hits = L(hits) / L(6);
      
      // Final Brain Score
      const brainScore = 100 * S_time * S_hits;
      
      // Formatierung: 1 Kommastelle mit %, auÃŸer bei 100%
      if (Math.abs(brainScore - 100) < 0.05) {
        return "100%";
      } else {
        return brainScore.toFixed(1).replace('.', ',') + '%';
      }
    }
    
    function showGameEnd() {
      gamePhase = 'ende';
      setButtonsDisabled(true);
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      document.getElementById('kippTarget').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      countdown.style.display = 'none';
      
      // Wie viele Treffer?
      const treffer = bereitsGetroffen.size;
      
      // Brain Score berechnen
      const scoreValue = calculateBrainScore(totalObservationTime, treffer);
      
      // hintText verstecken
      hintText.style.display = 'none';
      
      // Brain Score anzeigen
      const brainScore = document.getElementById('brainScore');
      if (scoreValue === "No Hit, no Score") {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">' + T.bs + ':<br>' + T.nh + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.st.replace("{t}",treffer).replace("{z}",totalObservationTime) + '</span>';
      } else {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">' + T.bs + ': ' + scoreValue + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.bw + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.st.replace("{t}",treffer).replace("{z}",totalObservationTime) + '</span>';
      }
      brainScore.style.display = 'block';
      brainScore.style.opacity = '1';
      
      // "Neues Spiel" Button anzeigen (Position wie Auge/Timer/weiter)
      actionButton.textContent = T.n;
      actionButton.style.display = 'block';
      actionButton.style.opacity = '1';
      if (timerTopPos) {
        actionButton.style.top = timerTopPos;
      }
      actionButton.style.left = '180px';
      actionButton.disabled = false;
    }


    // Array zum Speichern der ursprÃ¼nglichen opacity-Werte
    const savedCardOpacities = [];

    function startPausePhase() {
      gamePhase = 'pause';
      pauseExiting = false;
      document.getElementById('kippTarget').style.display = 'none';

      // Aktuelle opacity aller 6 KÃ¤rtchen speichern
      savedCardOpacities.length = 0;
      gameCards.forEach(c => {
        savedCardOpacities.push(c.mesh.material.opacity);
        c.mesh.material.transparent = true;
        c.mesh.material.needsUpdate = true;
      });
      
      shadowGradPlane.material.transparent = true;
      shadowGradPlane.material.needsUpdate = true;
      shadowGradPlane.material.opacity = 1;

      // Alle 6 KÃ¤rtchen auf opacity 0 animieren
      const startOpacities = savedCardOpacities.slice();
      animateVal(1, 0, 350, (t) => {
        gameCards.forEach((c, i) => { 
          c.mesh.material.opacity = startOpacities[i] * t; 
        });
        shadowGradPlane.material.opacity = t;
      }, () => {
        // KÃ¤rtchen komplett ausblenden
        gameCards.forEach(c => c.mesh.visible = false);
        pauseLights.forEach(l => l.visible = true);

        // Pause-Pivot auf der Ecke erstellen
        const cornerPos = new THREE.Vector3(0, 0, 0.109375);
        pausePivotGroup = new THREE.Group();
        pausePivotGroup.position.copy(cornerPos);
        kipGroup.add(pausePivotGroup);

        cube.updateMatrixWorld();
        const wp = new THREE.Vector3();
        cube.getWorldPosition(wp);
        const wq = new THREE.Quaternion();
        cube.getWorldQuaternion(wq);

        kipGroup.remove(cube);
        cube.position.copy(wp.clone().sub(cornerPos));
        cube.quaternion.copy(wq);
        pausePivotGroup.add(cube);

        pauseAlpha = 0;
        pauseBeta  = 0;
        pauseDragActive = false;

        // UI faden ein (ohne Text)
        hintText.style.display = 'none';
        actionButton.textContent = T.w;
        actionButton.style.opacity = '0';
        actionButton.style.display = 'block';

        // requestAnimationFrame damit display:block erstmal greift
        requestAnimationFrame(() => {
          actionButton.style.transition = 'opacity 0.4s ease';
          actionButton.style.opacity = '1';
        });
      });
    }

    function endPausePhase() {
      if (pauseExiting) return;
      pauseExiting = true;
      pauseSpringRunning = false;
      pauseDragActive = false;
      if (pauseTimerRef) { clearInterval(pauseTimerRef); pauseTimerRef = null; }

      // UI faden aus
      hintText.style.transition = 'opacity 0.35s ease';
      actionButton.style.transition = 'opacity 0.35s ease';
      hintText.style.opacity = '0';
      actionButton.style.opacity = '0';
      setTimeout(() => {
        hintText.style.display = 'none';
        actionButton.style.display = 'none';
      }, 350);

      // Schritt 1: Aufrichten von aktueller Position auf senkrecht (alpha=0, beta=0)
      const startAlpha = pauseAlpha;
      const startBeta  = pauseBeta;
      const aufrichtDur = 600;
      const aufrichtStart = Date.now();

      function animateAufrichten() {
        const elapsed = Date.now() - aufrichtStart;
        const progress = Math.min(elapsed / aufrichtDur, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        pauseAlpha = startAlpha * (1 - eased);
        pauseBeta  = startBeta  * (1 - eased);
        if (pausePivotGroup) pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');

        if (progress < 1) {
          requestAnimationFrame(animateAufrichten);
        } else {
          pauseAlpha = 0;
          pauseBeta  = 0;
          if (pausePivotGroup) pausePivotGroup.rotation.set(0, 0, 0, 'YXZ');
          // Schritt 2: Inverse aufEcke â€” zurÃ¼ck auf letzte Spielposition
          animateInverseAufEcke();
        }
      }
      animateAufrichten();
    }

    function animateInverseAufEcke() {
      const duration = 1200;
      const startTime = Date.now();
      const inverseQuat = aufEckeTargetQuat.clone().invert();

      function animateZurÃ¼ck() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        const currentQuat = new THREE.Quaternion().slerp(inverseQuat, eased);
        if (pausePivotGroup) pausePivotGroup.quaternion.copy(currentQuat);

        if (progress < 1) {
          requestAnimationFrame(animateZurÃ¼ck);
        } else {
          finishPauseToSpiel();
        }
      }
      animateZurÃ¼ck();
    }

    async function animateAufEcke() {
      const cornerPos = new THREE.Vector3(0, 0, 0.109375); // Die feste Ecke
      const duration = 1200;

      // Cube aus kipGroup nehmen, in pivotGroup bei der Ecke platzieren
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(cornerPos);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      const cubeWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(cubeWorldQuat);

      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(cornerPos));
      cube.quaternion.copy(cubeWorldQuat);
      pivotGroup.add(cube);

      // Ziel-Rotation: Vektor von Ecke zum WÃ¼rfelmittelpunkt soll nach +Y zeigen
      const relativePos = cube.position.clone().normalize();
      const targetDir = new THREE.Vector3(0, 1, 0);
      const targetQuat = new THREE.Quaternion().setFromUnitVectors(relativePos, targetDir);
      aufEckeTargetQuat = targetQuat.clone();

      const startTime = Date.now();

      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          const currentQuat = new THREE.Quaternion().copy(new THREE.Quaternion()).slerp(targetQuat, eased);
          pivotGroup.quaternion.copy(currentQuat);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Cleanup: wie finalizeKipp
            cube.updateMatrixWorld();
            const newWorldPos = new THREE.Vector3();
            cube.getWorldPosition(newWorldPos);
            const newWorldQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newWorldQuat);

            pivotGroup.remove(cube);
            kipGroup.remove(pivotGroup);

            cube.position.copy(newWorldPos);
            cube.quaternion.copy(newWorldQuat);
            kipGroup.add(cube);

            resolve();
          }
        }
        animate();
      });
    }

    function animateTreffer() {
      const card = gameCards[activeCardIdx];
      const mesh = card.mesh;
      
      // Kurze Puls-Animation (3 Pulse)
      const pulseDuration = 200; // ms pro Puls
      const pulseCount = 3;
      let currentPulse = 0;
      
      function doPulse() {
        if (currentPulse >= pulseCount) {
          // Animation fertig - Rahmen hinzufÃ¼gen
          drawGoldenBorder(card);
          
          // Weiter zur nÃ¤chsten Runde (onRunde erhÃ¶ht activeCardIdx und generiert nÃ¤chstes KÃ¤rtchen)
          onRunde();
          return;
        }
        
        // Puls: 1.0 â†’ 1.15 â†’ 1.0
        const startTime = performance.now();
        function animatePulse(now) {
          const t = Math.min((now - startTime) / pulseDuration, 1);
          const scale = 1.0 + Math.sin(t * Math.PI) * 0.15;
          mesh.scale.set(scale, scale, scale);
          
          if (t < 1) {
            requestAnimationFrame(animatePulse);
          } else {
            mesh.scale.set(1, 1, 1);
            currentPulse++;
            setTimeout(doPulse, 100); // Kurze Pause zwischen Pulsen
          }
        }
        requestAnimationFrame(animatePulse);
      }
      
      doPulse();
    }

    function animateNichtTreffer() {
      const card = gameCards[activeCardIdx];
      
      // Aktuelles KÃ¤rtchen durch leernohit ersetzen
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(leerImage, 0, 0, 85, 170);
      card.texture.needsUpdate = true;
      
      // Auf 60% transparent setzen
      card.mesh.material.transparent = true;
      card.mesh.material.opacity = 0.6;
      card.mesh.material.needsUpdate = true;
      
      // Markieren als gespielt (Nicht-Treffer) und zahl/color lÃ¶schen
      card.zahl = null;
      card.color = null;
      card.isMiss = true;
      
      // Weiter zur nÃ¤chsten Runde (onRunde erhÃ¶ht activeCardIdx und generiert nÃ¤chstes KÃ¤rtchen)
      onRunde();
    }

    let gamePhase = 'start';
    let currentMode = 'kanten';
    let kippCount = 0;
    let liegeZeiten = [];
    let liegeStartTime = null;
    let autoEvalTimeout = null;
    let countdownTimer = null;

    // UI fÃ¼r Demo-Phase initialisieren
    hintText.textContent = ''; // Leer lassen - Text-Sequenz Ã¼bernimmt
    actionButton.style.display = 'none';
    countdown.style.display = 'none';
    
    // Flag um Demo-Animation abbrechen zu kÃ¶nnen
    let isDemoAnimating = false;
    
    function startCountdown(onFinish, maxTime) {
      let timeElapsed = 0;
      countdown.textContent = timeElapsed;
      countdown.style.display = 'block';
      countdown.style.left = '180px';
      
      countdownTimer = setInterval(() => {
        timeElapsed++;
        totalObservationTime++;
        countdown.textContent = timeElapsed;
        if (maxTime && timeElapsed >= maxTime) {
          stopCountdown();
          countdown.style.display = 'none';
          if (onFinish) onFinish();
        }
      }, 1000);
    }
    
    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }
    
    // Timer deaktiviert
    let timerStarted = false;

    // =========================
    // DEMO-ANIMATION Phase 1
    // =========================
    
    function showTextAtWobble() {
      // Text-Animation deaktiviert
    }
    
    function startDemoAnimation() {
      // Hand auf Ursprungsposition zurÃ¼cksetzen
      handDemo.position.copy(handOriginalPos);
      handDemo.visible = true;
      handDemo.rotation.z = 0; // Initial keine Drehung
      
      const cubeStart = cube.position.clone();
      const cubeStartRot = cube.quaternion.clone();
      const handStart = handDemo.position.clone();
      
      const wippAngle = 20 * Math.PI / 180; // 20Â° Aufkipp-Winkel
      const wippDuration = 800; // ms pro Wipp
      const pauseBetween = 250; // ms Pause zwischen Wipps (reduziert)
      
      // Wipp Richtung Q0 (Nord, um X-Achse)
      function wippNord() {
        return new Promise(resolve => {
          isDemoAnimating = true;
          showTextAtWobble(); // Text genau beim Wobble-Start
          const startTime = performance.now();
          function animateWippNord(currentTime) {
            if (!isDemoAnimating) {
              resolve();
              return;
            }
            const elapsed = currentTime - startTime;
            const t = Math.min(elapsed / wippDuration, 1);
            const angle = Math.sin(t * Math.PI) * wippAngle; // Hin und zurÃ¼ck
            
            // WÃ¼rfel wippen
            cube.quaternion.copy(cubeStartRot);
            cube.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -angle)); // Negativ fÃ¼r Nord
            
            // Hand synchron bewegen (z-Richtung, nach hinten/Nord)
            const handOffset = Math.sin(t * Math.PI) * 0.1;
            handDemo.position.z = handStart.z - handOffset; // Nach Nord (kleinerer z-Wert)
            
            if (t < 1) {
              requestAnimationFrame(animateWippNord);
            } else {
              // ZurÃ¼ck zur Ausgangslage
              cube.quaternion.copy(cubeStartRot);
              cube.position.copy(cubeStart);
              handDemo.position.copy(handStart);
              handDemo.rotation.z = 0; // Rotation zurÃ¼cksetzen
              isDemoAnimating = false;
              setTimeout(resolve, pauseBetween);
            }
          }
          requestAnimationFrame(animateWippNord);
        });
      }
      
      // Wipp Richtung Q2 (Ost, um Z-Achse)
      function wippOst() {
        return new Promise(resolve => {
          isDemoAnimating = true;
          showTextAtWobble(); // Text genau beim Wobble-Start
          // Hand fÃ¼r Ost-Kipp neu positionieren (3 Zellen nÃ¶rdlicher, 2.77 Zellen westlicher)
          const handQ2PosZ = handStart.z - 0.46875;
          const handQ2PosX = handStart.x - 0.43375;
          handDemo.position.set(handQ2PosX, handDemo.position.y, handQ2PosZ);
          const handStartQ2 = handDemo.position.clone();
          handDemo.rotation.z = -Math.PI / 2; // 90Â° cw gedreht
          
          const startTime = performance.now();
          function animateWippOst(currentTime) {
            if (!isDemoAnimating) {
              resolve();
              return;
            }
            const elapsed = currentTime - startTime;
            const t = Math.min(elapsed / wippDuration, 1);
            const angle = Math.sin(t * Math.PI) * wippAngle;
            
            // WÃ¼rfel wippen
            cube.quaternion.copy(cubeStartRot);
            cube.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -angle));
            
            // Hand synchron bewegen (x-Richtung, nach rechts)
            const handOffset = Math.sin(t * Math.PI) * 0.1;
            handDemo.position.x = handStartQ2.x + handOffset;
            
            if (t < 1) {
              requestAnimationFrame(animateWippOst);
            } else {
              // ZurÃ¼ck zur Ausgangslage
              cube.quaternion.copy(cubeStartRot);
              cube.position.copy(cubeStart);
              handDemo.position.copy(handStart); // ZurÃ¼ck zur Original-Position!
              handDemo.rotation.z = 0; // Rotation zurÃ¼cksetzen
              isDemoAnimating = false;
              setTimeout(resolve, pauseBetween);
            }
          }
          requestAnimationFrame(animateWippOst);
        });
      }
      
      // Demo-Loop: Wobbles immer N-O-N, dann Pause, wieder N-O-N...
      function demoLoop() {
        if (gamePhase !== 'demo') {
          handDemo.visible = false;
          return;
        }
        
        // Immer N â†’ O â†’ N
        wippNord()
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            return wippOst();
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            // Pause zwischen "SCHAUEN" und "MERKEN": +0,4 Sek (reduziert)
            return new Promise(resolve => setTimeout(resolve, 400));
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            return wippNord();
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return;
            }
            // 3 Wobbles/Texte durch â†’ Hand ausblenden fÃ¼r Pause
            handDemo.visible = false;
            
            // Pause 1,5s, dann nÃ¤chster Zyklus (reduziert)
            setTimeout(() => {
              if (gamePhase === 'demo') {
                // Hand zurÃ¼cksetzen und wieder sichtbar machen
                handDemo.position.copy(handStart);
                handDemo.rotation.z = 0;
                handDemo.visible = true;
                demoLoop(); // NÃ¤chster Zyklus
              }
            }, 1500);
          })
          .catch(() => {
            // Demo wurde abgebrochen
          });
      }
      
      demoLoop();
    }
    
    // Demo starten nach kurzer VerzÃ¶gerung (reduziert)
    setTimeout(() => {
      if (gamePhase === 'demo') {
        startDemoAnimation(); // Texte erscheinen automatisch bei Wobbles
      }
    }, 600);
    
    // === PHASE 1: SPIEL ZIEL ===
    // Farbnamen fÃ¼r Tutorial-Anzeige
    var FARB_DISPLAY = {"violett":T.fV,"blau":T.fB,"gruen":T.fG,"orange":T.fO};


    
    // Beispiel-Kippziel aus aktueller WÃ¼rfellage (Q3, f2 oben) generieren
    function initSpielzielPhase() {
      // Bei Replay: Spielziel Ã¼berspringen, direkt zur Entscheidung
      if (isReplay) {
        initEntscheidungPhase();
        return;
      }
      
      gamePhase = 'spielziel';
      
      // Position immer auf erstes KÃ¤rtchen zurÃ¼cksetzen (wichtig nach "Neues Spiel")
      verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
      
      // ZufÃ¤lligen Slot wÃ¤hlen (S1-S4)
      const slotIdx = Math.floor(Math.random() * 4);
      const slotNames = ['S1', 'S2', 'S3', 'S4'];
      const beispielZahl = deck[8 + slotIdx]; // f2 offset = 8
      const beispielFarbe = SLOT_NEIGHBOR_COLORS[3][slotNames[slotIdx]]; // Q3
      const farbDisplay = FARB_DISPLAY[beispielFarbe] || beispielFarbe;
      
      // Beispiel-Kippziel auf verdecktesMesh zeichnen
      function drawBeispiel() {
        if (!texturesReady || !colorTargetImages[beispielFarbe]) {
          setTimeout(drawBeispiel, 50);
          return;
        }
        const img = colorTargetImages[beispielFarbe];
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(img, 0, 0, 85, 170);
        const displayText = beispielZahl + ((beispielZahl === 6 || beispielZahl === 9) ? '.' : '');
        verdecktesCtx.fillStyle = '#2a1810';
        verdecktesCtx.font = 'bold 56px Arial';
        verdecktesCtx.textAlign = 'center';
        verdecktesCtx.textBaseline = 'middle';
        verdecktesCtx.fillText(displayText, 42, 42);
        verdecktesCanvasTex.needsUpdate = true;
      }
      drawBeispiel();
      
      // Mesh sichtbar mit Beispiel, kein Puls
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Texte
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      
      // ZurÃ¼ck-Button zur Startseite zeigen (per 3D-Projektion positioniert)
      resetButton.style.display = 'block';
      const resetPos3D_sz = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      resetPos3D_sz.project(camera);
      const resetScreenX_sz = (resetPos3D_sz.x * 0.5 + 0.5) * 360;
      const resetScreenY_sz = (-resetPos3D_sz.y * 0.5 + 0.5) * 720;
      resetButton.style.left = resetScreenX_sz + 'px';
      resetButton.style.top = (resetScreenY_sz - 22 - 6) + 'px';
      
      const szText = document.getElementById('spielZielText');
      szText.innerHTML = "<b>" + T.s1 + "</b><br>" + T.s2.replace("{zahl}",beispielZahl).replace("{farbe}",farbDisplay);



      szText.style.display = 'block';
      
      // weiter-Button zentriert unter Text positionieren
      actionButton.textContent = T.w;
      actionButton.disabled = false;
      actionButton.style.display = 'block';
      actionButton.style.opacity = '1';
      
      setTimeout(() => {
        const szRect = szText.getBoundingClientRect();
        const containerRect = renderer.domElement.getBoundingClientRect();
        const topVal = (szRect.bottom - containerRect.top + 32) + 'px';
        actionButton.style.top = topVal;
        actionButton.style.left = '180px';
        timerTopPos = topVal; // Position fÃ¼r alle Timer merken
      }, 10);
    }
    let timerTopPos = null;
    // === START-OVERLAY: Warten auf Spieler-Wahl ===
    // =========================
    // AUTO-DEMO MODULE
    // =========================
    let autoDemoActive = false;

    // === SUBTITLE ENGINE ===
    const subEl = document.getElementById('demoSubtitle');

    async function showSubtitle(text, duration) {
      duration = duration || 2000;
      if (!text || text === '') return await sleep(duration); // skip empty lines
      subEl.innerHTML = text;
      subEl.style.display = 'block';
      subEl.style.opacity = '1';
      await sleep(duration);
      if (!autoDemoActive) { subEl.style.opacity = '0'; return; }
      subEl.style.opacity = '0';
      await sleep(350); // fade out transition time
    }

    async function showSubtitleSequence(lines, perLine) {
      perLine = perLine || 2500;
      for (let i = 0; i < lines.length; i++) {
        if (!autoDemoActive) return;
        const dur = (i === 0) ? 4000 : perLine;
        await showSubtitle(lines[i], dur);
      }
    }

    function hideSubtitle() {
      subEl.style.opacity = '0';
      setTimeout(() => { subEl.style.display = 'none'; }, 350);
    }

    // Solver: Find (steps, direction) to reach target (zahl + color) from current state
    function solveKippziel(zahl, colorName, fromQ, fromFace) {
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      let targetFace = null, targetQ = null;
      for (const face of ['f0', 'f1', 'f2']) {
        const off = faceOff[face];
        const slots = ['S1', 'S2', 'S3', 'S4'];
        for (let i = 0; i < 4; i++) {
          if (deck[off + i] === zahl) {
            for (let q = 0; q < 4; q++) {
              if (SLOT_NEIGHBOR_COLORS[q][slots[i]] === colorName) {
                targetFace = face; targetQ = q;
                break;
              }
            }
          }
          if (targetFace) break;
        }
        if (targetFace) break;
      }
      if (!targetFace) return null;
      const cwF = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccwF = { f2: 'f1', f1: 'f0', f0: 'f2' };
      const cwQ = { 3: 0, 0: 1, 1: 2, 2: 3 };
      const ccwQ = { 3: 2, 2: 1, 1: 0, 0: 3 };
      // Try CW
      let sQ = fromQ, sF = fromFace;
      for (let s = 1; s <= 6; s++) {
        sQ = cwQ[sQ]; sF = cwF[sF];
        if (sQ === targetQ && sF === targetFace) return { steps: s, dir: 'cw' };
      }
      // Try CCW
      sQ = fromQ; sF = fromFace;
      for (let s = 1; s <= 6; s++) {
        sQ = ccwQ[sQ]; sF = ccwF[sF];
        if (sQ === targetQ && sF === targetFace) return { steps: s, dir: 'ccw' };
      }
      return null;
    }

    // Draw kippziel on verdecktes mesh without side effects
    function autoRevealKippziel(zahl, colorObj) {
      erstesKippziel = { zahl: zahl, color: colorObj };
      const img = colorTargetImages[colorObj.name];
      if (!img) { console.error('autoReveal: Missing image for', colorObj.name); return; }
      verdecktesCtx.clearRect(0, 0, 85, 170);
      verdecktesCtx.drawImage(img, 0, 0, 85, 170);
      const displayText = zahl + ((zahl === 6 || zahl === 9) ? '.' : '');
      verdecktesCtx.fillStyle = '#2a1810';
      verdecktesCtx.font = 'bold 56px Arial';
      verdecktesCtx.textAlign = 'center';
      verdecktesCtx.textBaseline = 'middle';
      verdecktesCtx.fillText(displayText, 42, 42);
      verdecktesCanvasTex.needsUpdate = true;
      verdecktesMat.map = verdecktesCanvasTex;
      verdecktesMat.transparent = true;
      verdecktesMat.opacity = 1;
      verdecktesMat.needsUpdate = true;
      verdecktesMesh.material = verdecktesMat;
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMesh.userData.revealed = true;
    }

    // Perform N kipps in given direction (no game-state side effects)
    async function autoPerformKipps(steps, dir) {
      for (let i = 0; i < steps; i++) {
        let direction;
        if (dir === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north';
        } else {
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3';
        }
        isAnimating = false;
        kippDirection = dir;
        await performKipp(direction, 700);
        advanceTopFace();
        if (i < steps - 1) await sleep(300);
      }
      isAnimating = false;
    }

    // === HALF-KIPP WITH WOBBLE ===
    // Realistic "peek at 2 faces" technique: tilt to edge, wobble slowly, then complete
    async function halfKippWithWobble(direction, wobbleCount, wobblePause) {
      wobbleCount = wobbleCount || 3;
      wobblePause = wobblePause || 0; // extra pause after wobble before completing

      // Direction â†’ pivot definitions (same as performKipp)
      const defs = {
        'north':         { pivot: [-0.234375, 0, 0.109375],       ax: 'x', angle: -Math.PI/2, toQ: 0 },
        'south':         { pivot: [-0.234375, 0, 0.109375],       ax: 'x', angle:  Math.PI/2, toQ: 3 },
        'east':          { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle: -Math.PI/2, toQ: 1 },
        'west':          { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivot: [0.234375, 0, 0.109375],        ax: 'x', angle:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivot: [0.234375, 0, 0.109375],        ax: 'x', angle: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivot: [0, 0, 0.109375 + 0.234375],    ax: 'z', angle: -Math.PI/2, toQ: 2 }
      };
      const def = defs[direction];
      if (!def) return;

      const pivotPoint = new THREE.Vector3(def.pivot[0], def.pivot[1], def.pivot[2]);
      const fullAngle = def.angle;
      const halfAngle = fullAngle * 0.5;           // 45Â°
      const wobbleMin = fullAngle * 0.35;           // ~31.5Â°
      const wobbleMax = fullAngle * 0.65;           // ~58.5Â°

      // --- Setup pivot (cube stays in pivot for entire sequence) ---
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(pivotPoint));
      pivotGroup.add(cube);

      function setAngle(a) {
        if (def.ax === 'x') pivotGroup.rotation.x = a;
        else pivotGroup.rotation.z = a;
      }

      // Helper: animate angle from â†’ to
      function animAngle(from, to, dur) {
        return new Promise(resolve => {
          const startTime = performance.now();
          function tick() {
            const t = Math.min((performance.now() - startTime) / dur, 1);
            const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
            setAngle(from + (to - from) * ease);
            if (t < 1) requestAnimationFrame(tick);
            else { setAngle(to); resolve(); }
          }
          requestAnimationFrame(tick);
        });
      }

      // 1) Tilt to half angle (45Â°) â€” 600ms, smooth
      await animAngle(0, halfAngle, 600);

      // 2) Wobble: slow oscillation between wobbleMin and wobbleMax
      let currentAnglePos = halfAngle;
      for (let w = 0; w < wobbleCount; w++) {
        const target = (w % 2 === 0) ? wobbleMin : wobbleMax;
        await animAngle(currentAnglePos, target, 800);
        currentAnglePos = target;
      }
      // Return to halfAngle
      if (Math.abs(currentAnglePos - halfAngle) > 0.01) {
        await animAngle(currentAnglePos, halfAngle, 500);
      }

      // Optional extra pause (player is memorizing)
      if (wobblePause > 0) await sleep(wobblePause);

      // 3) Complete: animate from halfAngle to fullAngle â€” 500ms
      await animAngle(halfAngle, fullAngle, 500);

      // --- Finalize: extract cube from pivot ---
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);

      pivotGroup.remove(cube);
      kipGroup.remove(pivotGroup);
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);

      // Snap Y
      if (Math.abs(cube.position.y - offset) < 0.01) cube.position.y = offset;

      currentQuadrant = def.toQ;
      advanceTopFace();
    }

    // Show HIT/MISS on verdecktes mesh (no proceedToNextRound timer)
    function autoDemoShowResult(isHit) {
      if (isHit) {
        verdecktesCtx.shadowColor = '#FFD700';
        verdecktesCtx.shadowBlur = 12;
        verdecktesCtx.strokeStyle = '#FFD700';
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCtx.shadowBlur = 0;
        verdecktesCtx.strokeStyle = '#FFF0A0';
        verdecktesCtx.lineWidth = 1;
        verdecktesCtx.strokeRect(7, 7, 71, 156);
        verdecktesCanvasTex.needsUpdate = true;
        verdecktesMat.map = verdecktesCanvasTex;
        verdecktesMat.needsUpdate = true;
        // Pulse animation
        const startTime = performance.now();
        function pulseTick(now) {
          const t = Math.min((now - startTime) / 300, 1);
          const s = t < 0.5 ? 1 + 0.25 * (t * 2) : 1.25 - 0.25 * ((t - 0.5) * 2);
          verdecktesMesh.scale.set(s, s, s);
          if (t < 1) requestAnimationFrame(pulseTick);
          else verdecktesMesh.scale.set(1, 1, 1);
        }
        requestAnimationFrame(pulseTick);
      } else {
        const img = colorTargetImages[erstesKippziel.color.name];
        if (img) {
          verdecktesCtx.clearRect(0, 0, 85, 170);
          verdecktesCtx.drawImage(img, 0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'saturation';
          verdecktesCtx.fillStyle = 'hsl(0, 40%, 50%)';
          verdecktesCtx.fillRect(0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'source-over';
          const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
          verdecktesCtx.fillStyle = '#888888';
          verdecktesCtx.font = 'bold 56px Arial';
          verdecktesCtx.textAlign = 'center';
          verdecktesCtx.textBaseline = 'middle';
          verdecktesCtx.fillText(displayText, 42, 42);
        }
        verdecktesCtx.strokeStyle = '#FF2020';
        verdecktesCtx.lineWidth = 2;
        verdecktesCtx.strokeRect(1, 1, 83, 168);
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCanvasTex.needsUpdate = true;
        verdecktesMat.map = verdecktesCanvasTex;
        verdecktesMat.needsUpdate = true;
      }
      // Show subtitle
      showSubtitle(isHit ? T.d4h : T.d4m, 2000);
    }

    // Transfer verdecktes visual to gameCard
    function autoDemoTransferToCard(idx) {
      const card = gameCards[idx];
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(verdecktesCanvas, 0, 0);
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.visible = true;
    }

    // === MAIN AUTO-DEMO ORCHESTRATOR ===
    async function runAutoDemo() {
      autoDemoActive = true;
      gamePhase = 'autoDemo';

      // Hide start overlay
      document.getElementById('startOverlay').style.display = 'none';

      // Stop any lingering timers/animations from previous runs
      stopCountdown();
      if (autoEvalTimeout) { clearTimeout(autoEvalTimeout); autoEvalTimeout = null; }
      isDemoAnimating = false;
      handDemo.visible = false;

      // Reset cube to Q3, f2
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      currentQuadrant = 3;
      topFace = 'f2';
      kippDirection = 'cw';
      isAnimating = false;

      // Reset game state - COMPREHENSIVE
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      kippzielChecked = false;
      erstesKippziel = null;
      tapCount = 0;
      kippCount = 0;
      totalObservationTime = 0;
      lockedKippDir = null;
      currentDragDir = null;
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      timerStarted = false;
      dragActive = false;

      // Reset cards
      gameCards.forEach(c => { c.mesh.visible = false; c.zahl = null; c.color = null; c.isHit = false; c.isMiss = false; });

      // Hide all UI
      document.getElementById('spielZielText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      document.getElementById('brainScore').style.display = 'none';
      actionButton.style.display = 'none';
      countdown.style.display = 'none';
      hintText.style.display = 'none';
      hideSubtitle();
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      // Show reset button
      resetButton.style.display = 'block';
      const resetPos3D = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      resetPos3D.project(camera);
      resetButton.style.left = ((resetPos3D.x * 0.5 + 0.5) * 360) + 'px';
      resetButton.style.top = (((-resetPos3D.y * 0.5 + 0.5) * 720) - 28) + 'px';

      // Compute timerTopPos if not yet set (demo may run before spielziel)
      if (!timerTopPos) {
        timerTopPos = '553px';
      }

      // Hit/Miss pattern: 4 Hits, 2 Misses (realistic good player)
      const hitPattern = [true, true, false, true, true, false];

      // ==========================================
      // 6 ROUNDS
      // ==========================================
      for (let round = 0; round < 6; round++) {
        if (!autoDemoActive) return;
        await autoDemoRound(round, hitPattern[round]);
        if (!autoDemoActive) return;
      }

      // ==========================================
      // BRAIN SCORE
      // ==========================================
      hideSubtitle();
      verdecktesMesh.visible = false;
      document.getElementById('kippTarget').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      // Calculate and show Brain Score (reuse existing logic)
      const treffer = bereitsGetroffen.size;
      const scoreValue = calculateBrainScore(totalObservationTime, treffer);

      const brainScore = document.getElementById('brainScore');
      if (scoreValue === "No Hit, no Score") {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">' + T.bs + ':<br>' + T.nh + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.st.replace("{t}",treffer).replace("{z}",totalObservationTime) + '</span>';
      } else {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">' + T.bs + ': ' + scoreValue + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.bw + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + T.st.replace("{t}",treffer).replace("{z}",totalObservationTime) + '</span>';
      }
      brainScore.style.display = 'block';
      brainScore.style.opacity = '1';

      // Show score for 5 seconds, then back to start
      await sleep(5000);

      if (!autoDemoActive) return;
      autoDemoActive = false;

      // Cube zurÃ¼ck auf Start
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.quaternion.set(0, 0, 0, 1);
      currentQuadrant = 3;
      topFace = 'f2';
      backToStartScreen();
    }

    // === Single demo round ===
    async function autoDemoRound(roundIdx, shouldHit) {
      if (!autoDemoActive) return;

      activeCardIdx = roundIdx;

      // Helper: next CW direction from current quadrant
      function nextCwDir() {
        if (currentQuadrant === 3) return 'north';
        if (currentQuadrant === 0) return 'east';
        if (currentQuadrant === 1) return 'south_from_q1';
        return 'west_from_q2';
      }
      function nextCcwDir() {
        if (currentQuadrant === 3) return 'east_from_q3';
        if (currentQuadrant === 2) return 'north_from_q2';
        if (currentQuadrant === 1) return 'west';
        return 'south';
      }

      // ==========================================
      // 1) SHOW EYE ONLY + subtitle sequence
      // ==========================================
      const eyeIcon = document.getElementById('eyeIcon');
      eyeIcon.style.top = (parseInt(timerTopPos || '553') + 26) + 'px';
      eyeIcon.style.display = 'block';
      countdown.style.display = 'none';

      // Subtitle: explain eye (1.5s pause first to let user settle)
      await sleep(1500);
      if (!autoDemoActive) return;
      await showSubtitleSequence(T.d1, 2500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 2) AUTO-"CLICK" EYE â†’ SCHAUEN
      // ==========================================
      eyeIcon.style.display = 'none';

      // Show "0" (counter replaces eye)
      countdown.textContent = '0';
      countdown.style.display = 'block';
      countdown.style.top = (parseInt(timerTopPos) + 45) + 'px';
      countdown.style.left = '180px';

      await sleep(400);
      if (!autoDemoActive) return;

      // Start counter on first movement
      startCountdown(null, 120);
      countdown.style.top = (parseInt(timerTopPos) + 45) + 'px'; // demo offset

      // WOBBLES + d1b SUBTITLES run in parallel
      async function doWobbles() {
        kippDirection = 'cw';
        for (let hw = 0; hw < 3; hw++) {
          const wobbles = 3 - hw;
          const pause = (hw < 2) ? 300 : 100;
          await halfKippWithWobble(nextCwDir(), wobbles, pause);
          if (!autoDemoActive) return;
          if (hw < 2) await sleep(200);
        }

        // Random extra move
        const extraOption = Math.floor(Math.random() * 4);
        if (extraOption === 1) {
          kippDirection = 'ccw';
          await sleep(300);
          await halfKippWithWobble(nextCcwDir(), 2, 100);
        } else if (extraOption === 2) {
          kippDirection = 'cw';
          await sleep(300);
          await halfKippWithWobble(nextCwDir(), 2, 100);
        } else if (extraOption === 3) {
          kippDirection = 'ccw';
          await sleep(300);
          await halfKippWithWobble(nextCcwDir(), 2, 200);
          if (!autoDemoActive) return;
          await sleep(200);
          await halfKippWithWobble(nextCcwDir(), 1, 0);
        }
      }

      await Promise.all([
        doWobbles(),
        showSubtitleSequence(T.d1b, 2500)
      ]);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 3) PAUSE after SCHAUEN â€” counter keeps running
      // ==========================================
      await sleep(2000);
      if (!autoDemoActive) return;

      // Stop counter
      stopCountdown();
      countdown.style.display = 'none';

      // ==========================================
      // 4) SHOW VERDECKTES KIPPZIEL (pulsing) + subtitle
      // ==========================================
      const posX = cardStartX + roundIdx * (cardWidth + cardGap);
      verdecktesMesh.position.set(posX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      verdecktesMat.transparent = true;
      verdecktesMat.needsUpdate = true;
      verdecktesMesh.material = verdecktesMat;
      drawLeernohitOnVerdecktes();

      // Subtitle: "Klick dir dein KIPP ZIEL."
      await showSubtitle(T.d2, 2500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 5) AUTO-"CLICK" KIPPZIEL â†’ REVEAL
      // ==========================================
      console.log('Round ' + roundIdx + ' after SCHAUEN: Q=' + currentQuadrant + ' face=' + topFace);

      const erfuellteKombis = getCurrentErfuellteKombis();
      let kz = generateNeueKombiOhne(erfuellteKombis);
      if (!kz) kz = generateNeueKombiOhne(new Set());
      if (!kz) { console.error('No kombi available!'); return; }

      console.log('Revealing Kippziel:', kz.zahl, kz.color.name, 'img loaded:', !!colorTargetImages[kz.color.name]);
      autoRevealKippziel(kz.zahl, kz.color);
      bereitsAusgegeben.add(kz.zahl + '_' + kz.color.name);

      // ==========================================
      // 6) Show target circle + indicators (empty) immediately
      // ==========================================
      const kippTargetEl = document.getElementById('kippTarget');
      updateKippTargetPosition();
      kippTargetEl.style.width = '21px';
      kippTargetEl.style.height = '21px';
      kippTargetEl.style.animation = '';
      kippTargetEl.style.display = 'block';

      // Show indicator circles in adjacent quadrants (without numbers)
      tapCount = 0;
      updateTapIndicators();
      tapIndicatorA.mesh.visible = true;
      tapIndicatorB.mesh.visible = true;

      // ==========================================
      // 7) SUBTITLE SEQUENCE: explain kippziel + tippen/schubsen
      // ==========================================
      // Build d3 with actual zahl+farbe
      const farbDisplay = { violett: T.fV, blau: T.fB, gruen: T.fG, orange: T.fO };
      const d3Lines = T.d3.map(l => l.replace('{z}', kz.zahl).replace('{f}', (farbDisplay[kz.color.name] || kz.color.name)));

      await sleep(1500);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[0], 4000);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[1], 4500);
      if (!autoDemoActive) return;
      await showSubtitle(d3Lines[2], 4500);
      if (!autoDemoActive) return;
      hideSubtitle();

      // ==========================================
      // 8) SOLVE & TAP
      // ==========================================
      const solution = solveKippziel(kz.zahl, kz.color.name, currentQuadrant, topFace);
      console.log('Round ' + roundIdx + ' solution:', solution, 'for', kz.zahl, kz.color.name);

      if (!solution) {
        console.error('No solution found!');
        return;
      }

      kippDirection = solution.dir;

      let execSteps;
      if (shouldHit) {
        execSteps = solution.steps;
      } else {
        execSteps = (solution.steps < 6) ? solution.steps + 1 : solution.steps - 1;
      }

      // TAP sequence: 1 per second, circle grows, cube flashes
      const baseSize = 14;
      kippTargetEl.style.animation = 'none';
      tapCount = 0;
      for (let i = 1; i <= execSteps; i++) {
        tapCount = i;
        updateTapIndicators();

        const newSize = baseSize + i * 7;
        kippTargetEl.style.width = newSize + 'px';
        kippTargetEl.style.height = newSize + 'px';

        // Flash cube
        const origEmissive = cube.material[2].emissive.getHex();
        cube.material.forEach(m => { m.emissive.setHex(0x444444); });
        setTimeout(() => {
          cube.material.forEach(m => { m.emissive.setHex(origEmissive); });
        }, 150);

        await sleep(1000);
        if (!autoDemoActive) return;
      }

      // 1.3 sec after last tap â†’ execute
      await sleep(1300);

      // Hide target + indicators, execute kipps
      kippTargetEl.style.display = 'none';
      kippTargetEl.style.animation = '';
      kippTargetEl.style.width = '21px';
      kippTargetEl.style.height = '21px';
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;

      await autoPerformKipps(execSteps, solution.dir);
      if (!autoDemoActive) return;

      // 2 sec wait â†’ show result
      await sleep(2000);

      autoDemoShowResult(shouldHit);
      if (shouldHit) {
        bereitsGetroffen.add(kz.zahl + '_' + kz.color.name);
      }

      // 2 sec with result visible
      await sleep(2000);
      if (!autoDemoActive) return;

      // Transfer to gameCard
      autoDemoTransferToCard(roundIdx);
    }

    // =========================
    // BUTTON EVENT LISTENERS
    // =========================
    document.getElementById('btnSpielen').addEventListener('click', () => {
      if (!texturesReady) return;
      document.getElementById('startOverlay').style.display = 'none';
      isReplay = true;
      initSpielzielPhase();
    });
    document.getElementById('btnDemo').addEventListener('click', () => {
      if (!texturesReady) return;
      runAutoDemo();
    });
    
    document.getElementById('startBackBtn').addEventListener('click', () => {
      window.location.href = 'index.html';
    });
    
    // ZurÃ¼ck zur Startseite (resetButton in Start/Spielziel-Phase)
    function backToStartScreen() {
      document.getElementById('spielZielText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      document.getElementById('brainScore').style.display = 'none';
      actionButton.style.display = 'none';
      countdown.style.display = 'none';
      hideSubtitle();
      verdecktesMesh.visible = false;
      // Alle KÃ¤rtchen ausblenden
      gameCards.forEach(c => c.mesh.visible = false);
      // Tap-Indikatoren ausblenden
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      // Start-Buttons wieder zeigen
      document.getElementById('startOverlay').style.display = 'block';
      document.getElementById('btnSpielen').textContent = T.sp;
      document.getElementById('btnDemo').textContent = T.dm;
      // Full state reset so SPIELEN starts clean
      erstesKippziel = null;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      activeCardIdx = 0;
      gamePhase = 'start';
    }
    
    // === ENTSCHEIDUNGS-PHASE ===
    function initEntscheidungPhase() {
      gamePhase = 'entscheidung';
      
      // SpielZiel-Text ausblenden
      document.getElementById('spielZielText').style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      
      // Reset-Button zeigen (per 3D-Projektion positioniert)
      resetButton.style.display = 'block';
      const resetPos3D = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      resetPos3D.project(camera);
      const resetScreenX = (resetPos3D.x * 0.5 + 0.5) * 360;
      const resetScreenY = (-resetPos3D.y * 0.5 + 0.5) * 720;
      resetButton.style.left = resetScreenX + 'px';
      resetButton.style.top = (resetScreenY - 22 - 6) + 'px';
      
      // WÃ¼rfel in Q3, ruhig liegend (kein Reset nÃ¶tig - steht schon)
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      // Verdecktes KÃ¤rtchen pulsierend - IMMER auf linkeste Position (Index 0) zurÃ¼cksetzen
      verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Augen-Icon UNTER dem verdeckten Kippziel positionieren
      const eyeIcon = document.getElementById('eyeIcon');
      const vkPos = new THREE.Vector3().copy(verdecktesMesh.position);
      vkPos.project(camera);
      const vkScreenY = (-vkPos.y * 0.5 + 0.5) * 720;
      eyeIcon.style.top = (parseInt(timerTopPos || '553') + 26) + 'px'; // 55px unter Kippziel-Mitte
      eyeIcon.style.display = 'block';
      
      // Entscheidungs-Text nur beim ersten Mal zeigen
      const etText = document.getElementById('entscheidungText');
      if (isReplay) {
        etText.style.display = 'none';
      } else {
        etText.innerHTML = "<b>" + T.e1 + "</b><br>\u2022 " + T.e2 + "<br>\u2022 " + T.e3;
        etText.style.display = 'block';
      }
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }
    
    // Eye-Icon Click â†’ Schauen-Phase (Demo)
    const eyeEl = document.getElementById('eyeIcon');
    eyeEl.addEventListener('touchstart', (e) => {
      e.stopPropagation();
    }, { passive: false });
    eyeEl.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (gamePhase !== 'entscheidung') return;
      if (activeCardIdx === 0 && !isReplay) {
        spielzielToDemoPhase();
      } else {
        startFreeSchauenPhase();
      }
    }, { passive: false });
    eyeEl.addEventListener('click', (e) => {
      e.stopPropagation();
      if (gamePhase !== 'entscheidung') return;
      if (activeCardIdx === 0 && !isReplay) {
        spielzielToDemoPhase();
      } else {
        startFreeSchauenPhase();
      }
    });
    
    // Spielziel â†’ Demo Ãœbergang (jetzt von Entscheidung aufgerufen)
    function spielzielToDemoPhase() {
      gamePhase = 'demo';
      
      // Auge ausblenden, Timer zeigen
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      // Unsichtbarer Spacer fÃ¼r Text-Umfluss um animierte 3D-Hand
      const instrText = document.getElementById('instructionText');
      if (!instrText.querySelector('.hand-spacer')) {
        const spacer = document.createElement('div');
        spacer.className = 'hand-spacer';
        instrText.insertBefore(spacer, instrText.firstChild);
      }
      instrText.innerHTML = '<b>' + T.k1 + '</b><br>' + T.k2;
      instrText.style.display = isReplay ? 'none' : 'block';
      actionButton.style.display = 'none';
      
      // verdecktesMesh zurÃ¼ck auf leernohit + Puls
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      
      // WÃ¼rfel resetten fÃ¼r Demo
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      // Demo starten
      startDemoAnimation();
      
      // SCHAUEN-Timer: nur "00" anzeigen, startet erst bei erstem Kipp
      countdown.textContent = '0';
      countdown.style.display = 'block';
      if (timerTopPos) countdown.style.top = (parseInt(timerTopPos) + 45) + 'px';
      countdown.style.left = '180px';
    }
    
    function phaseKippenToSpielen() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      
      // WÃ¼rfel bleibt wo er in SCHAUEN war (kein Reset!)
      // topFace und currentQuadrant sind korrekt getrackt

      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons UNSICHTBAR und INAKTIV lassen
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Tutorial-Text NUR in Runde 1
      const tutText = document.getElementById('tutorialText');
      if (activeCardIdx === 0 && erstesKippziel && !isReplay) {
        const zahl = erstesKippziel.zahl;
        const farbe = FARB_DISPLAY[erstesKippziel.color.name] || erstesKippziel.color.name;
        tutText.innerHTML = "<b>" + T.p1 + "</b><br>" + T.p2.replace("{zahl}",zahl).replace("{farbe}",farbe);
        tutText.style.display = 'block';
      } else {
        tutText.style.display = 'none';
      }
      
      // Zielscheibe positionieren basierend auf aktuellem Quadranten
      updateKippTargetPosition();
      const targetEl = document.getElementById('kippTarget');
      targetEl.style.display = 'block';
      
      // Kein Timer-Display in Spielphase
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zurÃ¼cksetzen fÃ¼r 6-Kipp-Regel
      kippCount = 0;
      autoEvalTimeout = null;
      
      // Tap-Counter zurÃ¼cksetzen
      tapCount = 0;
      updateTapIndicators();
      
      // Liegezeit-Tracking (erste Liegezeit = Denkzeit, kein Auto-Eval)
      liegeZeiten = [];
      liegeStartTime = performance.now();

      // KÃ¤rtchen werden in fillAllCards() sichtbar gemacht - NICHT hier

      // KÃ¤rtchen befÃ¼llen: Nur das erste (Index 0) initial generieren
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      
      // Alle Card-Flags zurÃ¼cksetzen
      gameCards.forEach(c => {
        c.zahl = null;
        c.color = null;
        c.isHit = false;
        c.isMiss = false;
      });
      
      // Warten bis Texturen geladen sind, dann KÃ¤rtchen befÃ¼llen
      function fillAllCards() {
        if (!texturesReady || !leerImage) {
          setTimeout(fillAllCards, 50);
          return;
        }
        
        // Erstes KÃ¤rtchen mit bereits generiertem Kippziel befÃ¼llen
        if (erstesKippziel) {
          fillCardWithKombi(0, erstesKippziel.zahl, erstesKippziel.color);
        } else {
          // Fallback falls kein Kippziel vorgemerkt
          const erfuellteKombis = getCurrentErfuellteKombis();
          const visibleZahlen = getCurrentVisibleZahlen();
          const zahlenFilter = openKippzielPositions.has(0) && offeneKippzieleVergeben < 2 ? 'open' : 'closed';
          let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
          if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis);
          if (neueKombi) {
            if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
            fillCardWithKombi(0, neueKombi.zahl, neueKombi.color);
          }
        }
        
        // Restliche 5 KÃ¤rtchen (i=1 bis i=5) UNSICHTBAR machen
        for (let i = 1; i < 6; i++) {
          gameCards[i].mesh.visible = false;
        }
      }
      fillAllCards();
      
      setButtonsDisabled(false);
    }
    
    // === Spielen-Phase fÃ¼r Runde 2+ (ohne Reset) ===
    function startSpielenForCurrentRound() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      
      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons versteckt
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Zielscheibe positionieren und anzeigen
      updateKippTargetPosition();
      document.getElementById('kippTarget').style.display = 'block';
      
      // Timer aus
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zurÃ¼cksetzen
      kippCount = 0;
      autoEvalTimeout = null;
      
      // Tap-Counter zurÃ¼cksetzen
      tapCount = 0;
      updateTapIndicators();
      
      // Liegezeit-Tracking
      liegeZeiten = [];
      liegeStartTime = performance.now();
      
      // Aktuelles KÃ¤rtchen mit dem generierten Kippziel befÃ¼llen
      if (erstesKippziel) {
        fillCardWithKombi(activeCardIdx, erstesKippziel.zahl, erstesKippziel.color);
      }
      
      setButtonsDisabled(false);
    }

    actionButton.addEventListener('click', () => {
      if (gamePhase === 'spielziel') {
        initEntscheidungPhase();
      } else if (gamePhase === 'kippen') {
        phaseKippenToSpielen();
      } else if (gamePhase === 'pause') {
        endPausePhase();
      } else if (gamePhase === 'ende') {
        // "Neues Spiel" â†’ Reset + direkt ins Spiel (ohne ErklÃ¤rung)
        document.getElementById('brainScore').style.display = 'none';
        document.getElementById('brainScore').style.opacity = '0';
        isReplay = true;
        resetButton.click();
      }
    });
    
    // === Aufdecken des verdeckten Kippziels ===
    function revealVerdecktesKippziel() {
      if (!texturesReady) return;
      
      // SCHAUEN-Timer stoppen
      stopCountdown();
      countdown.style.display = 'none';
      
      // Demo-Animation stoppen falls noch aktiv
      isDemoAnimating = false;
      handDemo.visible = false;
      
      // Kippziel generieren mit open/closed Filter
      const erfuellteKombis = getCurrentErfuellteKombis();
      const visibleZahlen = getCurrentVisibleZahlen();
      
      let zahlenFilter = undefined;
      if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
        zahlenFilter = 'open';
      } else {
        zahlenFilter = 'closed';
      }
      
      erstesKippziel = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
      
      // Fallback: wenn Filter nichts liefert, ohne Filter versuchen
      if (!erstesKippziel) {
        erstesKippziel = generateNeueKombiOhne(erfuellteKombis);
      }
      if (!erstesKippziel) return;
      
      // Tracking: war es eine sichtbare Zahl?
      if (visibleZahlen.has(erstesKippziel.zahl)) {
        offeneKippzieleVergeben++;
      }
      
      // Farb-Image + Zahl auf verdecktes Canvas zeichnen
      const img = colorTargetImages[erstesKippziel.color.name];
      if (!img) return;
      
      verdecktesCtx.clearRect(0, 0, 85, 170);
      verdecktesCtx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
      verdecktesCtx.fillStyle = '#2a1810';
      verdecktesCtx.font = 'bold 56px Arial';
      verdecktesCtx.textAlign = 'center';
      verdecktesCtx.textBaseline = 'middle';
      verdecktesCtx.fillText(displayText, 42, 42);
      verdecktesCanvasTex.needsUpdate = true;
      
      // Puls stoppen, volle Deckkraft
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      verdecktesMesh.userData.revealed = true;
      
      // instructionText ausblenden
      document.getElementById('instructionText').style.display = 'none';
      // Entscheidungs-UI ausblenden
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      // Nach 1,5s Spielphase starten
      setTimeout(() => {
        if (activeCardIdx === 0) {
          phaseKippenToSpielen(); // Erste Runde: volles Init
        } else {
          startSpielenForCurrentRound(); // Folgerunden: ohne Reset
        }
      }, 1500);
    }
    
    // Tap-auf-WÃ¼rfel Flag
    let kippzielChecked = false;
    
    // verdecktes Kippziel Tap-Erkennung (Raycaster)
    const vkRaycaster = new THREE.Raycaster();
    const vkMouse = new THREE.Vector2();
    let lastTouchPos = null;
    
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (((gamePhase === 'kippen' || gamePhase === 'entscheidung') && verdecktesMesh.visible && !verdecktesMesh.userData.revealed) ||
          (gamePhase === 'spielen' && !kippzielChecked)) {
        lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }, { passive: true });
    
    renderer.domElement.addEventListener('touchend', (e) => {
      if ((gamePhase !== 'kippen' && gamePhase !== 'entscheidung') || !verdecktesMesh.visible || !lastTouchPos || verdecktesMesh.userData.revealed) return;
      if (dragActive) { lastTouchPos = null; return; }
      
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((lastTouchPos.x - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((lastTouchPos.y - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        revealVerdecktesKippziel();
      }
      lastTouchPos = null;
    }, { passive: true });
    
    // Desktop-Klick: Kippziel aufdecken (kippen) ODER WÃ¼rfel-Tap (spielen)
    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      // Spielen: Tap auf WÃ¼rfel
      if (gamePhase === 'spielen' && !kippzielChecked && !isAnimating) {
        if (vkRaycaster.intersectObject(cube).length > 0 && tapCount < 6) {
          tapCount++;
          updateTapIndicators();
          
        }
        return;
      }
      
      if ((gamePhase !== 'kippen' && gamePhase !== 'entscheidung') || !verdecktesMesh.visible || verdecktesMesh.userData.revealed) return;
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        revealVerdecktesKippziel();
      }
    });
    
    // (Spielen: Tap auf WÃ¼rfel zÃ¤hlt Kipps, Swipe startet Auto-Kipp-Sequenz)
    
    // Kippziel-Check bei Tap auf WÃ¼rfel
    function checkKippzielTap() {
      if (!erstesKippziel || kippzielChecked) return;
      kippzielChecked = true;
      
      // Auto-Eval Timeout sicherheitshalber lÃ¶schen
      if (autoEvalTimeout) {
        clearTimeout(autoEvalTimeout);
        autoEvalTimeout = null;
      }
      
      // Timer stoppen
      stopCountdown();
      
      // 6-Kipp-Regel: mehr als 6 = auto-miss
      if (kippCount > 6) {
        console.log('=== AUTO-MISS: mehr als 6 Kipps ===');
        drawKippzielBorder(false);
        return;
      }
      
      // Treffer prÃ¼fen
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      const off = faceOff[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };
      
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === erstesKippziel.zahl) { hitSlot = slot; break; }
      }
      
      let isHit = false;
      if (hitSlot) {
        const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
        isHit = (neighborColor === erstesKippziel.color.name);
      }
      
      console.log('=== KIPPZIEL AUTO-EVAL ===');
      console.log('Ziel:', erstesKippziel.zahl, erstesKippziel.color.name);
      console.log('topFace:', topFace, 'Q:', currentQuadrant, 'kippCount:', kippCount);
      console.log('Sichtbare Slots:', JSON.stringify(visible));
      console.log('hitSlot:', hitSlot);
      if (hitSlot) console.log('Farbe an Slot:', SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot]);
      console.log('Ergebnis:', isHit ? 'TREFFER' : 'MISS');
      
      drawKippzielBorder(isHit);
    }
    
    function drawKippzielBorder(isHit) {
      if (isHit) {
        // Treffer: goldgelber Rahmen mit Outer Glow
        // Glow-Effekt (mehrere halbtransparente Rahmen auÃŸenâ†’innen)
        verdecktesCtx.shadowColor = '#FFD700';
        verdecktesCtx.shadowBlur = 12;
        verdecktesCtx.strokeStyle = '#FFD700';
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCtx.shadowBlur = 0;
        
        // Innerer heller Rahmen
        verdecktesCtx.strokeStyle = '#FFF0A0';
        verdecktesCtx.lineWidth = 1;
        verdecktesCtx.strokeRect(7, 7, 71, 156);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Puls-Animation: kurz grÃ¶ÃŸer, dann zurÃ¼ck
        const origScale = 1;
        const pulseScale = 1.25;
        const pulseDur = 300;
        const startTime = performance.now();
        function pulseTick(now) {
          const t = Math.min((now - startTime) / pulseDur, 1);
          const s = t < 0.5
            ? origScale + (pulseScale - origScale) * (t * 2)
            : pulseScale - (pulseScale - origScale) * ((t - 0.5) * 2);
          verdecktesMesh.scale.set(s, s, s);
          if (t < 1) requestAnimationFrame(pulseTick);
          else verdecktesMesh.scale.set(origScale, origScale, origScale);
        }
        requestAnimationFrame(pulseTick);
        
        // Nach 2s zur nÃ¤chsten Runde
        setTimeout(() => proceedToNextRound(true), 2000);
        
      } else {
        // Miss: Zahl grau zeichnen
        const img = colorTargetImages[erstesKippziel.color.name];
        if (img) {
          verdecktesCtx.clearRect(0, 0, 85, 170);
          verdecktesCtx.drawImage(img, 0, 0, 85, 170);
          
          // FarbsÃ¤ttigung reduzieren
          verdecktesCtx.globalCompositeOperation = 'saturation';
          verdecktesCtx.fillStyle = 'hsl(0, 40%, 50%)';
          verdecktesCtx.fillRect(0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'source-over';
          
          // Zahl in Grau
          const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
          verdecktesCtx.fillStyle = '#888888';
          verdecktesCtx.font = 'bold 56px Arial';
          verdecktesCtx.textAlign = 'center';
          verdecktesCtx.textBaseline = 'middle';
          verdecktesCtx.fillText(displayText, 42, 42);
        }
        
        // Roter Rahmen
        verdecktesCtx.strokeStyle = '#FF2020';
        verdecktesCtx.lineWidth = 2;
        verdecktesCtx.strokeRect(1, 1, 83, 168);
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Nach 2s zur nÃ¤chsten Runde
        setTimeout(() => proceedToNextRound(false), 2000);
      }
    }

    function proceedToNextRound(isHit) {
      // 1. Visuellen Zustand von verdecktesMesh auf gameCard Ã¼bertragen
      const card = gameCards[activeCardIdx];
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(verdecktesCanvas, 0, 0);
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.visible = true;
      
      // 2. Treffer tracken
      if (isHit && erstesKippziel) {
        bereitsGetroffen.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 3. Kombi als ausgegeben markieren
      if (erstesKippziel) {
        bereitsAusgegeben.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 4. Weiter
      activeCardIdx++;
      
      // 5. Spielende?
      if (activeCardIdx >= 6) {
        verdecktesMesh.visible = false;
        document.getElementById('kippTarget').style.display = 'none';
        showGameEnd();
        return;
      }
      
      // 6. NÃ¤chste Entscheidungs-Runde
      initNextRoundEntscheidung();
    }

    function initNextRoundEntscheidung() {
      gamePhase = 'entscheidung';
      kippzielChecked = false;
      erstesKippziel = null;
      
      // ALLE Texte ausblenden - nach erstem Kippziel keine Texte mehr
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      tapCount = 0;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      
      // Richtungs-Lock zurÃ¼cksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // verdecktesMesh an nÃ¤chste KÃ¤rtchen-Position verschieben
      const nextX = cardStartX + activeCardIdx * (cardWidth + cardGap);
      verdecktesMesh.position.set(nextX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Auge an fester Position einblenden (zentriert, pulsierend)
      const eyeIcon = document.getElementById('eyeIcon');
      eyeIcon.style.display = 'block';
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }

    function startFreeSchauenPhase() {
      gamePhase = 'kippen';
      
      // Ensure timerTopPos is set (skipped when isReplay bypasses spielziel)
      if (!timerTopPos) timerTopPos = '553px';
      
      // Auge ausblenden, keine Texte
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      
      // Timer "0" anzeigen und starten (60 Sek max)
      countdown.textContent = '0';
      countdown.style.display = 'block';
      if (timerTopPos) countdown.style.top = (parseInt(timerTopPos) + 45) + 'px';
      countdown.style.left = '180px';
      
      startCountdown(() => {
        if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        }
      }, 60);
      
      // WÃ¼rfel bleibt wo er ist - KEIN Reset!
    }

    backButton.addEventListener('click', () => {
      if (gamePhase !== 'kippen' && gamePhase !== 'spielen') return;
      gamePhase = 'kippen'; // ZurÃ¼ck zu Phase 2
      currentMode = 'kanten';
      kippCount = 0;
      if (autoEvalTimeout) { clearTimeout(autoEvalTimeout); autoEvalTimeout = null; }
      
      // UI zurÃ¼cksetzen zu Phase 2
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      stopCountdown();
      countdown.style.display = 'none';
      if (activeCardIdx === 0 && !isReplay) {
        document.getElementById('instructionText').style.display = 'block';
      }
      document.getElementById('tutorialText').style.display = 'none';
      
      // SCHAUEN-Timer neu starten
      startCountdown(() => {
        if ((gamePhase === 'demo' || gamePhase === 'kippen') && !verdecktesMesh.userData.revealed) {
          gamePhase = 'kippen';
          revealVerdecktesKippziel();
        }
      }, 60);
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = false;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      erstesKippziel = null;
      kippzielChecked = false;
      lockedKippDir = null;
      currentDragDir = null;
      tapCount = 0;
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      drawLeernohitOnVerdecktes();
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      // KÃ¤rtchen verstecken
      gameCards.forEach(c => c.mesh.visible = false);
      
      // WÃ¼rfel zurÃ¼cksetzen zu Q3
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.rotation.set(0, 0, 0);
      currentQuadrant = 3;
      topFace = 'f2'; // Anfangslage zurÃ¼cksetzen
      
    });
    
    // Reset-Button: Intelligente Navigation
    // - Auf Start-Overlay â†’ zurÃ¼ck zu index.html (HauptmenÃ¼)
    // - In Spielziel-Phase â†’ zurÃ¼ck zum Start-Overlay
    // - In allen anderen Phasen â†’ Reset + zurÃ¼ck zum Start-Overlay
    resetButton.addEventListener('click', () => {
      if (gamePhase === 'start') {
        // Auf Start-Overlay â†’ zurÃ¼ck zum HauptmenÃ¼
        window.location.href = 'index.html';
        return;
      }
      
      // Abort auto-demo if active
      autoDemoActive = false;
      
      stopCountdown();
      if (autoEvalTimeout) { clearTimeout(autoEvalTimeout); autoEvalTimeout = null; }
      countdown.style.display = 'none';
      isDemoAnimating = false;
      handDemo.visible = false;
      
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      gameCards.forEach(c => c.mesh.visible = false);
      
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      kippCount = 0;
      lockedKippDir = null;
      currentDragDir = null;
      erstesKippziel = null;
      kippzielChecked = false;
      totalObservationTime = 0;
      tapCount = 0;
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      
      gamePhase = 'start';
      backToStartScreen();
    });

    // =========================
    // WÃœRFEL-KIPPMECHANIK
    // =========================
    // DRAG-KIPP-STEUERUNG (Phase 2)
    // =========================
    let isSwiping = false;
    let swipeStartX = 0;
    let swipeStartY = 0;
    let isAnimating = false;
    let currentQuadrant = 3;

    // Drag-State
    let dragActive = false;
    let dragPivotGroup = null;
    let dragAxis = null;
    let dragTargetSign = 0;
    let dragToQ = 0;
    let dragCurrentAngle = 0;
    const DRAG_SENSITIVITY = 150; // px fÃ¼r volle 90Â°

    // =========================
    // PAUSE-PHASE: Ecke-Drehinteraktion
    // =========================
    // 8 Ecken des WÃ¼rfels nach body-diagonal-Rotation (Pivot = Ecke, vorberechnet)
    const ECKE_CORNERS = [
      [ 0.000000,  0.000000,  0.000000],
      [ 0.369691,  0.270633, -0.099059],
      [-0.270633,  0.270633, -0.270633],
      [-0.099059,  0.270633,  0.369691],
      [ 0.099059,  0.541266, -0.369691],
      [ 0.270633,  0.541266,  0.270633],
      [-0.369691,  0.541266,  0.099059],
      [ 0.000000,  0.811899,  0.000000]
    ];
    // Frame-Grenzen relativ zum Pivot (0, 0, 0.109375)
    const PAUSE_LIMIT_S =  0.4705;   // sÃ¼d  (wallInnerSouth - pivotZ)
    const PAUSE_LIMIT_N =  0.46875;  // nord
    const PAUSE_LIMIT_E =  0.46875;  // ost
    const PAUSE_LIMIT_W =  0.46875;  // west

    function isPausePoseValid(alpha, beta) {
      const ca = Math.cos(alpha), sa = Math.sin(alpha);
      const cb = Math.cos(beta),  sb = Math.sin(beta);
      for (const [x, y, z] of ECKE_CORNERS) {
        // Ry(Î²) zuerst
        const x1 =  x * cb + z * sb;
        const z1 = -x * sb + z * cb;
        // Rx(Î±) danach
        const z2 = y * sa + z1 * ca;
        // x Ã¤ndert sich durch Rx nicht â†’ x1 bleiben
        if ( x1 > PAUSE_LIMIT_E || -x1 > PAUSE_LIMIT_W) return false;
        if ( z2 > PAUSE_LIMIT_S || -z2 > PAUSE_LIMIT_N) return false;
      }
      return true;
    }

    function getMaxBeta(alpha, sign) {
      // sign: +1 oder -1
      if (!isPausePoseValid(alpha, 0)) return 0;
      let lo = 0, hi = Math.PI;
      for (let i = 0; i < 16; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(alpha, sign * mid)) lo = mid; else hi = mid;
      }
      return lo;
    }

    function getMaxAlpha(beta) {
      if (!isPausePoseValid(0, beta)) return 0;
      let lo = 0, hi = Math.PI / 6; // 30Â° als obere Suche
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(mid, beta)) lo = mid; else hi = mid;
      }
      return lo;
    }

    let pausePivotGroup = null;
    let aufEckeTargetQuat = null;
    let pauseSpringRunning = false;
    let pauseTimerRef = null;
    let pauseExiting = false;
    let savedCubePosition = null;  // Position vor animateAufEcke
    let savedCubeQuaternion = null; // Quaternion vor animateAufEcke
    let savedTopFace = null;  // topFace vor animateAufEcke
    let savedCurrentQuadrant = null; // currentQuadrant vor animateAufEcke
    let pauseAlpha = 0;
    let pauseBeta  = 0;
    let pauseDragActive = false;
    let pauseDragStartX = 0;
    let pauseDragStartY = 0;
    let pauseDragStartAlpha = 0;
    let pauseDragStartBeta  = 0;
    const PAUSE_SENSITIVITY = 200; // px fÃ¼r ~30Â°
    let totalObservationTime = 0; // Sekunden fÃ¼r Brain Score Berechnung

    function getKippConfig(direction) {
      const configs = {
        'north':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation: -Math.PI/2, toQ: 0 },
        'south':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation:  Math.PI/2, toQ: 3 },
        'east':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 1 },
        'west':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 2 }
      };
      return configs[direction];
    }

    function getValidDirection(deltaX, deltaY) {
      if (Math.abs(deltaY) >= Math.abs(deltaX)) {
        if (deltaY < 0) {
          if (currentQuadrant === 3) return 'north';
          if (currentQuadrant === 2) return 'north_from_q2';
        } else {
          if (currentQuadrant === 0) return 'south';
          if (currentQuadrant === 1) return 'south_from_q1';
        }
      } else {
        if (deltaX > 0) {
          if (currentQuadrant === 0) return 'east';
          if (currentQuadrant === 3) return 'east_from_q3';
        } else {
          if (currentQuadrant === 1) return 'west';
          if (currentQuadrant === 2) return 'west_from_q2';
        }
      }
      return null;
    }


    renderer.domElement.addEventListener('touchstart', (e) => {
      // Start-Phase: keine Touch-Interaktion
      if (gamePhase === 'start') return;
      // Demo-Phase beenden beim ersten Touch
      if (gamePhase === 'demo') {
        e.preventDefault(); // Touch wÃ¤hrend Demo verarbeiten
        
        gamePhase = 'kippen';
        isDemoAnimating = false; // Animation sofort stoppen
        handDemo.visible = false; // Hand sofort ausblenden
        
        // SCHAUEN-Timer jetzt starten (60 Sek)
        startCountdown(() => {
          if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
            revealVerdecktesKippziel();
          }
        }, 60);
        
        // ALLE State-Variablen sauber resetten
        cube.quaternion.set(0, 0, 0, 1); // Reset zu neutraler Rotation
        cube.position.set(-offset, offset, 0.109375 + offset);
        currentQuadrant = 3;
        topFace = 'f2';
        dragActive = false;
        isAnimating = false;
        
        // Touch-Punkt SOFORT fÃ¼r Drag-System speichern
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        
        // Auch fÃ¼r Raycaster (verdecktes Kippziel) speichern
        if (verdecktesMesh.visible) {
          lastTouchPos = { x: touch.clientX, y: touch.clientY };
        }
        
        return; // Demo-Stop komplett, jetzt touchmove Ã¼bernimmt
      }
      
      if (gamePhase === 'pause' && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        pauseDragStartX = touch.clientX;
        pauseDragStartY = touch.clientY;
        pauseDragStartAlpha = pauseAlpha;
        pauseDragStartBeta  = pauseBeta;
        pauseDragActive = true;
        return;
      }
      if (currentMode === 'kanten' && (gamePhase === 'kippen' || gamePhase === 'spielen')) {
        if (isAnimating) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        dragActive = false;
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (gamePhase === 'pause' && pauseDragActive && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        const dx = touch.clientX - pauseDragStartX;
        const dy = touch.clientY - pauseDragStartY;

        // Î²: X-Drag â†’ Y-Rotation (links = positiv)
        let newBeta  = pauseDragStartBeta  + (dx / PAUSE_SENSITIVITY) * Math.PI;
        // Î±: Y-Drag nach unten â†’ Tilt nach SÃ¼den
        let newAlpha = pauseDragStartAlpha + (dy / PAUSE_SENSITIVITY) * (Math.PI / 3);
        newAlpha = Math.max(0, newAlpha);

        // Alpha clampen bei gegebenem Beta
        const maxA = getMaxAlpha(newBeta);
        newAlpha = Math.min(newAlpha, maxA);

        // Beta clampen bei gegebenem Alpha
        if (!isPausePoseValid(newAlpha, newBeta)) {
          const sign = newBeta >= 0 ? 1 : -1;
          const maxB = getMaxBeta(newAlpha, sign);
          newBeta = sign * maxB;
        }

        pauseAlpha = newAlpha;
        pauseBeta  = newBeta;

        // Euler 'YXZ': erst Ry(Î²), dann Rx(Î±)
        pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');
        return;
      }
      if (!isSwiping || isAnimating || (gamePhase !== 'kippen' && gamePhase !== 'spielen') || currentMode !== 'kanten') return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - swipeStartX;
      const deltaY = touch.clientY - swipeStartY;

      // Warte auf minimale Bewegung bevor Richtung bestimmt wird
      if (!dragActive) {
        if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < 8) return;

        const direction = getValidDirection(deltaX, deltaY);
        if (!direction) { isSwiping = false; return; }
        
        // SPIELEN-Phase: Swipe bestimmt Richtung â†’ Auto-Kipp-Sequenz
        if (gamePhase === 'spielen') {
          isSwiping = false;
          if (tapCount <= 0 || kippzielChecked || isAnimating) return;
          
          const isCW = CW_DIRS.has(direction);
          lockedKippDir = isCW ? 'cw' : 'ccw';
          kippDirection = lockedKippDir;
          
          // Tutorial-Text ausblenden
          document.getElementById('tutorialText').style.display = 'none';
          
          // Auto-Kipp starten
          runAutoKippSequence(tapCount);
          return;
        }
        
        // SCHAUEN-Phase: normaler manueller Drag
        currentDragDir = direction;

        const config = getKippConfig(direction);
        dragAxis = config.axis;
        dragTargetSign = config.targetRotation > 0 ? 1 : -1;
        dragToQ = config.toQ;

        // Pivot-Gruppe setup
        dragPivotGroup = new THREE.Group();
        dragPivotGroup.position.copy(config.pivotPoint);
        kipGroup.add(dragPivotGroup);

        cube.updateMatrixWorld();
        const cubeWorldPos = new THREE.Vector3();
        cube.getWorldPosition(cubeWorldPos);
        kipGroup.remove(cube);
        cube.position.copy(cubeWorldPos.clone().sub(config.pivotPoint));
        dragPivotGroup.add(cube);

        dragActive = true;
        dragCurrentAngle = 0;
      }

      // Rotation live berechnen
      // X-Achse: deltaY direkt (oben neg, unten pos)
      // Z-Achse: -deltaX (rechts pos wird neg Rotation)
      const relevantDelta = (dragAxis === 'x') ? deltaY : -deltaX;
      let angle = (relevantDelta / DRAG_SENSITIVITY) * (Math.PI / 2);

      // Clamp zwischen 0 und targetRotation
      if (dragTargetSign > 0) {
        angle = Math.max(0, Math.min(Math.PI / 2, angle));
      } else {
        angle = Math.min(0, Math.max(-Math.PI / 2, angle));
      }

      dragCurrentAngle = angle;

      if (dragAxis === 'x') {
        dragPivotGroup.rotation.x = dragCurrentAngle;
      } else {
        dragPivotGroup.rotation.z = dragCurrentAngle;
      }
    });

    function finishPauseToSpiel() {
      // PivotGroup auflÃ¶sen
      if (pausePivotGroup) {
        pausePivotGroup.remove(cube);
        kipGroup.remove(pausePivotGroup);
        pausePivotGroup = null;
        kipGroup.add(cube);
      }

      // Gespeicherter Zustand vor der Pause â€” immer wiederherstellen
      cube.position.copy(savedCubePosition);
      cube.quaternion.copy(savedCubeQuaternion);
      topFace = savedTopFace;
      currentQuadrant = savedCurrentQuadrant;

      gamePhase = 'spielen';
      // Buttons bleiben versteckt (Tutorial-Modus: Swipe-Kipping)
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      updateKippTargetPosition();
      document.getElementById('kippTarget').style.display = 'block';

      // Pause-Lichter aus
      pauseLights.forEach(l => l.visible = false);
      
      // Nur die bereits gespielten KÃ¤rtchen sichtbar machen und opacity wiederherstellen
      gameCards.forEach((c, i) => {
        if (c.zahl || c.isHit || c.isMiss) {
          c.mesh.visible = true;
          if (i < savedCardOpacities.length) {
            c.mesh.material.opacity = savedCardOpacities[i];
            c.mesh.material.transparent = (savedCardOpacities[i] < 1);
            c.mesh.material.needsUpdate = true;
          }
        }
      });
      
      setButtonsDisabled(false);
    }

    renderer.domElement.addEventListener('touchend', () => {
      if (gamePhase === 'pause') {
        pauseDragActive = false;
        return;
      }
      isSwiping = false;
      
      // SPIELEN-Phase: Tap auf WÃ¼rfel = tapCount erhÃ¶hen
      if (gamePhase === 'spielen' && !dragActive && !kippzielChecked && !isAnimating && lastTouchPos) {
        const rect = renderer.domElement.getBoundingClientRect();
        vkMouse.x = ((lastTouchPos.x - rect.left) / rect.width) * 2 - 1;
        vkMouse.y = -((lastTouchPos.y - rect.top) / rect.height) * 2 + 1;
        vkRaycaster.setFromCamera(vkMouse, camera);
        if (vkRaycaster.intersectObject(cube).length > 0) {
          if (tapCount < 6) {
            tapCount++;
            updateTapIndicators();
            
          }
        }
        lastTouchPos = null;
        return;
      }
      
      if (!dragActive) return;

      // Tipping-Point bei 45Â° (PI/4)
      const absAngle = Math.abs(dragCurrentAngle);
      let targetAngle, finalQ;

      if (absAngle > Math.PI / 4) {
        targetAngle = dragTargetSign * Math.PI / 2; // Kippen
        finalQ = dragToQ;
      } else {
        targetAngle = 0; // ZurÃ¼ckfallen
        finalQ = currentQuadrant;
      }

      // Schwerkraft-Fall-Animation
      isAnimating = true;
      const startAngle = dragCurrentAngle;
      const angleDiff = targetAngle - startAngle;
      const fallDuration = Math.max(150, Math.abs(angleDiff) / (Math.PI / 2) * 420);
      const startTime = Date.now();

      function animateFall() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fallDuration, 1);

        // Ease-in (tÂ²) = Schwerkraft-Beschleunigung
        const eased = progress * progress;
        const currentAngle = startAngle + angleDiff * eased;

        if (dragAxis === 'x') {
          dragPivotGroup.rotation.x = currentAngle;
        } else {
          dragPivotGroup.rotation.z = currentAngle;
        }

        if (progress < 1) {
          requestAnimationFrame(animateFall);
        } else {
          if (targetAngle === 0) {
            // ZurÃ¼ckgefallen: WÃ¼rfel zurÃ¼ck in kipGroup
            cube.updateMatrixWorld();
            const newPos = new THREE.Vector3();
            cube.getWorldPosition(newPos);
            const newQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newQuat);
            dragPivotGroup.remove(cube);
            kipGroup.remove(dragPivotGroup);
            cube.position.copy(newPos);
            cube.quaternion.copy(newQuat);
            kipGroup.add(cube);
          } else {
            // Gekippt: finalisieren
            finalizeKipp(finalQ, null);
            
            // topFace bei jedem Kipp aktualisieren (kippen + spielen)
            if ((gamePhase === 'kippen' || gamePhase === 'spielen') && currentDragDir) {
              const isCW = CW_DIRS.has(currentDragDir);
              kippDirection = isCW ? 'cw' : 'ccw';
              advanceTopFace();
            }
          }
          dragActive = false;
          dragPivotGroup = null;
          isAnimating = false;
        }
      }

      animateFall();
    });

    // Desktop-Support: Click startet Spielphase
    renderer.domElement.addEventListener('click', (e) => {
      if (gamePhase === 'demo') {
        gamePhase = 'kippen';
        handDemo.visible = false;
        
        // Direkt prÃ¼fen ob verdecktes Kippziel angeklickt wurde
        if (verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
          const rect = renderer.domElement.getBoundingClientRect();
          vkMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          vkMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          vkRaycaster.setFromCamera(vkMouse, camera);
          if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
            revealVerdecktesKippziel();
          }
        }
        return;
      }
    });
    
    async function performKipp(direction, duration = 800) {
      if (isAnimating) return;
      isAnimating = true;
      
      let pivotPoint, axis, targetRotation, fromQ, toQ;
      
      if (direction === 'north') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 0;
      } else if (direction === 'south') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 0;
        toQ = 3;
      } else if (direction === 'east') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 0;
        toQ = 1;
      } else if (direction === 'west') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 0;
      } else if (direction === 'south_from_q1') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 2;
      } else if (direction === 'north_from_q2') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 2;
        toQ = 1;
      } else if (direction === 'west_from_q2') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 2;
        toQ = 3;
      } else if (direction === 'east_from_q3') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 2;
      }
      
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);
      
      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      
      kipGroup.remove(cube);
      
      const relativePos = cubeWorldPos.clone().sub(pivotPoint);
      cube.position.copy(relativePos);
      pivotGroup.add(cube);
      
      const startTime = Date.now();
      
      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          if (axis === 'x') {
            pivotGroup.rotation.x = eased * targetRotation;
          } else {
            pivotGroup.rotation.z = eased * targetRotation;
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            finalizeKipp(toQ, resolve);
          }
        }
        
        animate();
      });
    }
    
    function finalizeKipp(newQ, callback) {
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);
      
      const parent = cube.parent;
      if (parent && parent.parent) {
        parent.parent.remove(parent);
      }
      
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);
      
      currentQuadrant = newQ;
      isAnimating = false;
      if (callback) callback();
    }

    // =========================
    // KIPP-SEQUENZ mit 2D-Timing
    // =========================
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runKippSequence(steps) {
      if (isAnimating) return;
      
      const T = getTiming();
      const kipFactor = 1;
      
      
      for (let i = 0; i < steps; i++) {
        const tStep = (steps <= 1) ? 0 : (i / (steps - 1));
        const stepMul = lerp(1.0, STEP_MAX, tStep);
        
        const kipTime = Math.max(40, Math.round(T.kipMs * kipFactor * stepMul));
        const holdTime = Math.max(40, Math.round(T.wMs * stepMul));
        
        
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north'; // Q3
        } else {
          // CCW: umgekehrte Reihenfolge
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3'; // Q3
        }
        
        await performKipp(direction, kipTime);
        advanceTopFace();
        await sleep(holdTime);
      }
    }

    // === Auto-Kipp-Sequenz fÃ¼r Spielphase ===
    async function runAutoKippSequence(steps) {
      if (isAnimating || kippzielChecked) return;
      isAnimating = true;
      
      // Tap-Counter und Zielkreis ausblenden
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      document.getElementById('kippTarget').style.display = 'none';
      
      for (let i = 0; i < steps; i++) {
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north';
        } else {
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3';
        }
        
        isAnimating = false; // performKipp setzt isAnimating selbst
        await performKipp(direction, 700);
        advanceTopFace();
        
        // Kurze Pause zwischen Kipps
        if (i < steps - 1) {
          await sleep(300);
        }
      }
      
      kippCount = steps;
      isAnimating = false;
      
      // Trefferwertung nach kurzem Moment
      await sleep(200);
      checkKippzielTap();
    }

    // =========================
    // CW/CCW Richtung
    let kippDirection = 'cw';
    
    // Richtungsklassifizierung fÃ¼r Swipe-Kipping
    const CW_DIRS = new Set(['east', 'south_from_q1', 'west_from_q2', 'north']);
    const CCW_DIRS = new Set(['south', 'west', 'north_from_q2', 'east_from_q3']);
    let lockedKippDir = null; // null, 'cw', 'ccw'
    let currentDragDir = null;
    
    const cwBtn = document.getElementById('cwBtn');
    const ccwBtn = document.getElementById('ccwBtn');

    function updateRichtungButtons() {
      if (kippDirection === 'cw') {
        cwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        cwBtn.style.color = '#c0b870';
        cwBtn.style.borderColor = '#d4b48c';
        cwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        ccwBtn.style.color = '#c0b8a8';
        ccwBtn.style.borderColor = '#808080';
        ccwBtn.style.boxShadow = '';
      } else {
        ccwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        ccwBtn.style.color = '#c0b870';
        ccwBtn.style.borderColor = '#d4b48c';
        ccwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        cwBtn.style.color = '#c0b8a8';
        cwBtn.style.borderColor = '#808080';
        cwBtn.style.boxShadow = '';
      }
    }
    // CW/CCW werden durch triggerKipp weiter unten gehandelt

    // =========================
    // Zwei-Schritt Ablauf: erst Zahl wÃ¤hlen, dann Richtung
    // =========================
    let selectedAnzahl = null;

    function setButtonsDisabled(disabled) {
      document.querySelectorAll('.kippBtn').forEach(btn => {
        btn.disabled = disabled;
        btn.classList.remove('pulsing');
        if (!disabled) {
          btn.style.background = btn.id === 'cwBtn' || btn.id === 'ccwBtn'
            ? 'linear-gradient(180deg,#404040 0%,#303030 100%)'
            : 'linear-gradient(180deg,#606060 0%,#404040 100%)';
          btn.style.color = '#c0b8a8';
          btn.style.borderColor = '#808080';
          btn.style.boxShadow = '';
        }
      });
      if (!disabled) startZahlWarten();
    }

    function pulseZahlenButtons(on) {
      document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
        if (on) btn.classList.add('pulsing');
        else btn.classList.remove('pulsing');
      });
    }
    function pulseRichtungButtons(on) {
      if (on) { cwBtn.classList.add('pulsing'); ccwBtn.classList.add('pulsing'); }
      else    { cwBtn.classList.remove('pulsing'); ccwBtn.classList.remove('pulsing'); }
    }

    function startZahlWarten() {
      selectedAnzahl = null;
      pulseZahlenButtons(true);
      pulseRichtungButtons(false);
      // Richtungsbuttons neutral (keine Hervorhebuung)
      cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      cwBtn.style.color = '#c0b8a8';
      cwBtn.style.borderColor = '#808080';
      cwBtn.style.boxShadow = '';
      ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      ccwBtn.style.color = '#c0b8a8';
      ccwBtn.style.borderColor = '#808080';
      ccwBtn.style.boxShadow = '';
    }

    function startRichtungWarten() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(true);
    }

    function stopAllenPulse() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(false);
    }

    // Zahl-Buttons: nur Zahl speichern, kein Kipp
    document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gamePhase !== 'spielen') return;
        if (selectedAnzahl !== null) return; // schon eine Zahl gewÃ¤hlt

        selectedAnzahl = parseInt(btn.dataset.anzahl);

        // GewÃ¤hlte Zahl hervorheben
        btn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        btn.style.color = '#c0b870';
        btn.style.borderColor = '#d4b48c';
        btn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';

        startRichtungWarten();
      });
    });

    // CW/CCW: wenn Zahl schon gewÃ¤hlt â†’ Kipp starten
    async function triggerKipp(direction) {
      if (gamePhase !== 'spielen') return;
      if (selectedAnzahl === null) return; // noch keine Zahl â†’ nur Richtung anzeigen

      const anzahl = selectedAnzahl;
      stopAllenPulse();
      setButtonsDisabled(true);

      kippDirection = direction;
      updateRichtungButtons();

      // Zielkreis ausblenden wÃ¤hrend Kipp-Animation
      document.getElementById('kippTarget').style.display = 'none';

      // KÃ¤rtchen auf Original zurÃ¼cksetzen - Image neu zeichnen
      const card = gameCards[activeCardIdx];
      const img = colorTargetImages[card.color.name];
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = card.zahl + ((card.zahl === 6 || card.zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      card.texture.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.material.opacity = 1.0;

      await runKippSequence(anzahl);

      // Treffer-PrÃ¼fung
      const treffer = checkTreffer();
      if (treffer) {
        bereitsGetroffen.add(card.zahl + '_' + card.color.name);
        animateTreffer();
      } else {
        animateNichtTreffer();
      }
    }

    cwBtn.addEventListener('click', () => triggerKipp('cw'));
    ccwBtn.addEventListener('click', () => triggerKipp('ccw'));

    // Animation loop
    function renderLoop() {
      requestAnimationFrame(renderLoop);
      
      // Puls-Animation fÃ¼r verdecktes Kippziel (nur wenn nicht aufgedeckt)
      if (verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
        const t = (Date.now() % 1500) / 1500 * Math.PI * 2;
        const pulse = (Math.sin(t) + 1) / 2; // 0 bis 1
        const s = 1 + 0.08 * pulse;
        verdecktesMesh.scale.set(s, s, s);
        verdecktesMat.opacity = 1 - 0.4 * pulse;
      }
      
      renderer.render(scene, camera);
    }

    // resetButton auf Einstiegsseite sofort sichtbar + positionieren
    resetButton.style.display = 'block';
    {
      const rp = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      rp.project(camera);
      resetButton.style.left = (rp.x * 0.5 + 0.5) * 360 + 'px';
      resetButton.style.top = ((-rp.y * 0.5 + 0.5) * 720 - 22 - 6) + 'px';
    }

    renderLoop();
  </script>
</body>
</html>
