<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D W√ºrfel - Vollst√§ndig</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
    }

    #container { 
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 720px;
      overflow: hidden;
      touch-action: none;
    }

    #container canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none;
      user-select: none;
    }

    /* UI OVERLAY */
    #uiOverlay {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 360px;
      height: 100vh;
      pointer-events: none;
      z-index: 100;
    }

    #hintText {
      position: absolute;
      top: 460px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 36px;
      font-weight: bold;
      color: #d4b48c;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(212,180,140,0.5);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.6));
      pointer-events: none;
      width: 360px;
      overflow: visible;
      line-height: 1.2;
      opacity: 0;
      will-change: transform, opacity, text-shadow;
      backface-visibility: hidden;
      -webkit-font-smoothing: antialiased;
    }
    
    #brainScore {
      position: absolute;
      top: 526px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      width: 360px;
      line-height: 1.2;
      opacity: 0;
      display: none;
    }

    #countdown {
      position: absolute;
      top: 475px;
      left: 180px;
      transform: translateX(-50%);
      font-size: 50px;
      font-weight: bold;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                   0 0 10px rgba(255,255,255,0.5);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
      pointer-events: none;
      display: none;
    }
    #eyeIcon {
      position: absolute;
      top: 475px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: auto;
      cursor: pointer;
      pointer-events: auto;
      filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4));
      display: none;
      z-index: 150;
      animation: eyePulse 1.5s ease-in-out infinite;
    }
    @keyframes eyePulse {
      0%, 100% { transform: translateX(-50%) scale(1); filter: drop-shadow(0 2px 6px rgba(255,255,255,0.4)); }
      50% { transform: translateX(-50%) scale(1.12); filter: drop-shadow(0 2px 12px rgba(255,255,255,0.7)); }
    }
    #kippTarget {
      position: absolute;
      width: 21px;
      height: 21px;
      border: 3px solid #4a2a10;
      border-radius: 50%;
      pointer-events: none;
      display: none;
      z-index: 120;
      transform: translate(-50%, -50%);
      animation: targetPulse 1.5s ease-in-out infinite;
    }
    #kippTarget::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 6px;
      background: #4a2a10;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    @keyframes targetPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
      50% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.5; }
    }
    #entscheidungText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      color: #d4b48c;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      line-height: 1.4;
      text-align: left;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      display: none;
      z-index: 100;
    }
    
    #instructionText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #instructionText .hand-spacer {
      float: left;
      width: 105px;
      height: 46px;
      margin: 0 10px 0 0;
    }
    
    #tutorialText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #spielZielText {
      position: absolute;
      top: 421px;
      left: 66px;
      width: 284px;
      text-align: left;
      font-size: 11pt;
      font-family: Arial, sans-serif;
      color: #d4b48c;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
      line-height: 1.4;
      display: none;
    }
    
    #verdecktesKippziel {
      position: absolute;
      width: 45px;
      height: 90px;
      left: 10px;
      top: 481px;
      cursor: pointer;
      z-index: 300;
      animation: pulsate 1.5s ease-in-out infinite;
      transform-origin: center center;
    }
    
    @keyframes pulsate {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.08); }
    }

    #actionButton {
      position: absolute;
      top: 540px;
      left: 180px;
      transform: translateX(-50%);
      padding: 8px 28px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 22px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    #actionButton:hover {
      background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%);
      transform: translateX(-50%) translateY(-2px);
    }

    #actionButton:active {
      transform: translateX(-50%) translateY(0);
      background: linear-gradient(180deg, #505050 0%, #303030 100%);
    }

    #actionButton.pulse {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    @keyframes kippPulse {
      0%, 100% { box-shadow: 0 0 4px rgba(212,180,140,0.2); }
      50% { box-shadow: 0 0 10px rgba(212,180,140,0.7), 0 0 22px rgba(212,180,140,0.4); }
    }
    .kippBtn.pulsing {
      animation: kippPulse 1.2s ease-in-out infinite;
    }

    @keyframes textGoldenPulse {
      0%, 100% { 
        transform: translateX(-50%) scale(1);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 10px rgba(212,180,140,0.3);
      }
      50% { 
        transform: translateX(-50%) scale(1.25);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
    }

    @keyframes textSinglePulse {
      0% { 
        opacity: 0;
        transform: translateX(-50%) scale(0.95) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 5px rgba(212,180,140,0.2);
      }
      65% { 
        opacity: 1;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 20px rgba(212,180,140,0.9),
                     0 0 40px rgba(212,180,140,0.5);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(1.05) translateZ(0);
        text-shadow: 0 2px 4px rgba(0,0,0,0.8),
                     0 0 12px rgba(212,180,140,0.3);
      }
    }


    /* BUTTONS 1-6 */
    #kippButtons {
      position: absolute;
      top: 605px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      pointer-events: auto;
      z-index: 200;
    }

    .kippBtn {
      width: 52px;
      height: 52px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      color: #c0b8a8;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    #cwBtn, #ccwBtn {
      background: linear-gradient(180deg, #404040 0%, #303030 100%);
    }
      background: linear-gradient(180deg, #ffffff 0%, #f8f8f8 50%, #f0f0f0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.5),
                  inset 0 1px 0 rgba(255,255,255,0.9);
    }

    .kippBtn:active:not(:disabled) {
      transform: translateY(0);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    .kippBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .kippBtn.running {
      background: linear-gradient(180deg, #ffdd00 0%, #ffcc00 50%, #ffbb00 100%);
      border-color: #cc9900;
    }

    .kippBtn.clicked {
      background: linear-gradient(180deg, #4a3e28 0%, #3a2e1c 100%) !important;
      border-color: #d4b48c !important;
      color: #f0e0c0 !important;
      box-shadow: 0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35), inset 0 0 6px rgba(212,180,140,0.15);
    }

    #resetButton {
      display: none;
      position: absolute;
      width: 45px;
      height: 45px;
      background: linear-gradient(180deg, #606060 0%, #404040 100%);
      border: 2px solid #808080;
      border-radius: 8px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all 0.15s ease;
      z-index: 200;
      padding: 0;
    }

    #resetButton:active {
      transform: scale(0.95);
      background: linear-gradient(180deg, #505050 0%, #303030 100%);
    }

    #resetButton svg {
      width: 26px;
      height: 26px;
      display: block;
      margin: auto;
      margin-top: 2px;
    }

    #backButton {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 50%, #e0e0e0 100%);
      border: 1px solid #c0c0c0;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.8);
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    #backButton:active {
      transform: scale(0.95);
      background: linear-gradient(180deg, #f0f0f0 0%, #e0e0e0 50%, #d0d0d0 100%);
      box-shadow: 0 1px 2px rgba(0,0,0,0.4),
                  inset 0 1px 2px rgba(0,0,0,0.2);
    }

    #handIcon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      font-size: 50px;
      pointer-events: none;
      top: 270px;
      display: none;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div id="uiOverlay">
    <div id="handIcon">üëÜ</div>
    <div id="hintText"></div>
    <div id="instructionText"><b>SCHAUEN & MERKEN</b><br>Kippe den W√ºrfel in der Box in beliebige Richtung von Ecke zu Ecke. Merke dir m√∂glichst viele Zahlenpositionen in m√∂glichst kurzer Zeit (Nutze SCHAU-Sek. effektiv).<br>Nach dem SCHAUEN deckst du hier links dein erstes von sechs Kippzielen auf.</div>
    <img id="verdecktesKippziel" src="leernohit.webp" style="display:none;">
    <div id="tutorialText"></div>
    <div id="spielZielText"></div>
    <div id="entscheidungText"></div>
    <div id="kippTarget"></div>
    <div id="brainScore"></div>
    <div id="countdown">60</div>
    <img id="eyeIcon" src="data:image/png;base64,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" />
    <button id="actionButton">weiter</button>
    <button id="backButton">‚Üª</button>
    <button id="resetButton"><svg viewBox="0 0 24 24" fill="none" stroke="#c0b8a8" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 5l-7 7 7 7"/></svg></button>
    
    <div id="richtungButtons" class="hidden" style="position:absolute;top:540px;left:50%;transform:translateX(-50%);display:flex;gap:21px;width:180px;z-index:200;">
      <button id="cwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">‚Üª</span></button>
      <button id="ccwBtn" class="kippBtn" style="flex:1;height:45px;font-size:40px;line-height:1;position:relative;"><span style="position:absolute;top:calc(50% - 3px);left:50%;transform:translate(-50%,-50%);font-size:40px;">‚Ü∫</span></button>
    </div>

    <!-- Buttons 1-6 - Vern√ºnftig positioniert -->
    <div id="kippButtons" class="hidden">
      <button class="kippBtn" data-anzahl="1">1</button>
      <button class="kippBtn" data-anzahl="2">2</button>
      <button class="kippBtn" data-anzahl="3">3</button>
      <button class="kippBtn" data-anzahl="4">4</button>
      <button class="kippBtn" data-anzahl="5">5</button>
      <button class="kippBtn" data-anzahl="6">6</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================
    // Scene Setup
    // =========================
    const scene = new THREE.Scene();
    // scene.background gel√∂scht - body background (#000000) wird sichtbar

    const containerWidth = 360;
    const containerHeight = 720;
    
    const camera = new THREE.PerspectiveCamera(
      50,
      containerWidth / containerHeight,
      0.01,
      100
    );
    
    const baseY = 2.143;
    const verticalAngle = -1.0;
    const horizontal = 0;
    const radius = 1.25;
    const southShift = -0.143;
    
    camera.position.set(
      0 + Math.sin(horizontal) * 0.5,
      baseY + radius * Math.sin(-verticalAngle),
      radius * Math.cos(verticalAngle) + Math.cos(horizontal) * 0.3 + southShift
    );
    
    camera.lookAt(0, 0.46875, 0.7 + southShift);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(360, 720);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    document.getElementById('container').appendChild(renderer.domElement);

    // =========================
    // BELEUCHTUNG
    // =========================
    // Zus√§tzliche Pause-Lichter (von allen Seiten, subtil)
    const pauseLights = [
      new THREE.DirectionalLight(0xffffff, 0.25), // links
      new THREE.DirectionalLight(0xffffff, 0.25), // rechts
      new THREE.DirectionalLight(0xffffff, 0.2),  // hinten
      new THREE.DirectionalLight(0xffffff, 0.15)  // unten
    ];
    pauseLights[0].position.set(-3, 2, 1);
    pauseLights[1].position.set(3, 2, 1);
    pauseLights[2].position.set(0, 2, -3);
    pauseLights[3].position.set(0, -1, 2);
    pauseLights.forEach(l => { l.visible = false; scene.add(l); });

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.68);
    mainLight.position.set(0, 8.708, -0.46875);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 20;
    mainLight.shadow.camera.left = -2;
    mainLight.shadow.camera.right = 2;
    mainLight.shadow.camera.top = 2;
    mainLight.shadow.camera.bottom = -2;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
    fillLight.position.set(1, 3, 1);
    scene.add(fillLight);

    const fillLightSouth = new THREE.DirectionalLight(0xffffff, 0.28);
    fillLightSouth.position.set(0, 2, 4);
    scene.add(fillLightSouth);

    // =========================
    // TISCH (œÄ1 Ebene)
    // =========================
    // Boxboden (6x6 Zellen, zentriert um Achsenmittelpunkt)
    const boxbodenTexture = new THREE.TextureLoader().load('Boxboden.webp');
    const boxbodenSize = 6 * 0.15625; // 0.9375
    const boxbodenGeometry = new THREE.PlaneGeometry(boxbodenSize, boxbodenSize);
    const boxbodenMaterial = new THREE.MeshStandardMaterial({ 
      map: boxbodenTexture,
      roughness: 0.8,
      metalness: 0.2
    });
    const boxboden = new THREE.Mesh(boxbodenGeometry, boxbodenMaterial);
    boxboden.rotation.x = -Math.PI / 2;
    boxboden.position.set(0, 0.001, 0.109375);
    boxboden.receiveShadow = true;
    scene.add(boxboden); // Zur√ºck zu scene direkt
    
    const gridSize = 16 * 0.15625;
    const gridDivisions = 16;
    
    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xff8800, 0xff8800);
    gridHelper.position.y = 0.001;
    gridHelper.position.z = 0.421875;
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;
    scene.add(gridHelper);
    
    const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0x888888);
    gridHelper2.position.y = 0.46875;
    gridHelper2.position.z = 0.421875;
    gridHelper2.material.opacity = 0.3;
    gridHelper2.material.transparent = true;
    gridHelper2.visible = false;
    scene.add(gridHelper2);

    // K√§rtchen auf dem Spieltisch (œÄ1, orange Raster)
    const cardWidth = 0.15625;   // 1 Zelle
    const cardHeight = 0.3125;   // 2 Zellen
    const cardGap = (1.25 - 6 * cardWidth) / 5 - 4 * (2.5 / 720); // 6 Karten, Gap -4px
    const cardY = 0.001 + 3 * 0.15625 + 0.002; // auf Spieltisch (3 Zellen √ºber œÄ1)
    const cardZ = 0.109375 + 4 * 0.15625 + 0.15625 + 15 * (2.5 / 720); // 4 Zeilen s√ºdlich, + 15px

    const totalCardsWidth = 6 * cardWidth + 5 * cardGap; // Tats√§chliche Breite aller K√§rtchen + Gaps
    const cardStartX = -totalCardsWidth / 2 + cardWidth / 2;

    const gameCards = [];
    
    // Farb-Ziel-Texturen als HTML Images laden
    const colorTargetImages = {};
    const colorTargetTextures = {};
    const imageLoadPromises = [];
    
    const colorNames = ['blau', 'orange', 'gruen', 'violett'];
    colorNames.forEach(name => {
      const promise = new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          colorTargetImages[name] = img;
          const texture = new THREE.Texture(img);
          texture.needsUpdate = true;
          colorTargetTextures[name] = texture;
          console.log(`${name}zielhit.webp loaded`);
          resolve();
        };
        img.onerror = () => {
          console.error(`Failed to load ${name}zielhit.webp`);
          reject();
        };
        img.src = `${name}zielhit.webp`;
      });
      imageLoadPromises.push(promise);
    });
    
    // Leer-Image laden
    let leerImage = null;
    const leerPromise = new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        leerImage = img;
        console.log('leernohit.webp loaded');
        resolve();
      };
      img.onerror = () => {
        console.error('Failed to load leernohit.webp');
        reject();
      };
      img.src = 'leernohit.webp';
    });
    imageLoadPromises.push(leerPromise);
    
    // Warten bis alle Bilder geladen sind
    let texturesReady = false;
    Promise.all(imageLoadPromises).then(() => {
      texturesReady = true;
      console.log('All 4 color textures ready');
      // WICHTIG: Button erst jetzt aktivieren
      actionButton.disabled = false;
    }).catch(() => {
      console.error('Some textures failed to load');
      texturesReady = true;
      actionButton.disabled = false; // Trotzdem weitermachen
    });
    
    for (let i = 0; i < 6; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = 85;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      // Canvas leer lassen - wird durch fillCard() beim Spielstart gef√ºllt

      const texture = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(cardWidth, cardHeight);
      const mat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        side: THREE.DoubleSide 
      });
      const plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.set(cardStartX + i * (cardWidth + cardGap), cardY, cardZ);
      plane.castShadow = true;
      plane.receiveShadow = true;
      scene.add(plane);
      plane.visible = false;

      gameCards.push({ mesh: plane, canvas: canvas, ctx: ctx, texture: texture });
    }
    
    // === Verdecktes Kippziel als 3D-Mesh auf dem Spieltisch (Canvas-basiert) ===
    const verdecktesCanvas = document.createElement('canvas');
    verdecktesCanvas.width = 85;
    verdecktesCanvas.height = 170;
    const verdecktesCtx = verdecktesCanvas.getContext('2d');
    const verdecktesCanvasTex = new THREE.CanvasTexture(verdecktesCanvas);
    
    // leernohit.webp initial draufzeichnen sobald geladen
    function drawLeernohitOnVerdecktes() {
      if (leerImage) {
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(leerImage, 0, 0, 85, 170);
        verdecktesCanvasTex.needsUpdate = true;
      } else {
        setTimeout(drawLeernohitOnVerdecktes, 50);
      }
    }
    drawLeernohitOnVerdecktes();
    
    const verdecktesGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);
    const verdecktesMat = new THREE.MeshBasicMaterial({ 
      map: verdecktesCanvasTex, 
      side: THREE.DoubleSide,
      transparent: true
    });
    const verdecktesMesh = new THREE.Mesh(verdecktesGeo, verdecktesMat);
    verdecktesMesh.rotation.x = -Math.PI / 2;
    verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
    scene.add(verdecktesMesh);
    
    // Gespeichertes erstes Kippziel
    let erstesKippziel = null;
    
    // === Tap-Counter Anzeige in benachbarten Quadranten ===
    // Benachbarte Quadranten pro W√ºrfelposition
    const ADJACENT_Q = { 0: [3, 1], 1: [0, 2], 2: [1, 3], 3: [0, 2] };
    
    const tapIndicatorY = cardY + 0.003;
    const tapIndicatorSize = 0.28;
    
    function createTapIndicator() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const tex = new THREE.CanvasTexture(canvas);
      const geo = new THREE.PlaneGeometry(tapIndicatorSize, tapIndicatorSize);
      const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.visible = false;
      scene.add(mesh);
      return { mesh, canvas, ctx, tex };
    }
    
    const tapIndicatorA = createTapIndicator();
    const tapIndicatorB = createTapIndicator();
    
    let tapCount = 0;
    
    function drawTapIndicator(indicator, n) {
      const ctx = indicator.ctx;
      ctx.clearRect(0, 0, 128, 128);
      if (n <= 0) { indicator.tex.needsUpdate = true; return; }
      
      // √Ñu√üerer Ring mit metallischem Silber
      const grad = ctx.createRadialGradient(64, 64, 30, 64, 64, 56);
      grad.addColorStop(0, 'rgba(200,210,220,0)');
      grad.addColorStop(0.6, 'rgba(180,190,200,0.15)');
      grad.addColorStop(0.85, 'rgba(200,210,220,0.4)');
      grad.addColorStop(1, 'rgba(160,170,180,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 128, 128);
      
      // Zahl mit Silber-Glanz
      ctx.save();
      ctx.font = 'bold 72px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Schatten f√ºr Tiefe
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 2;
      
      // Silber-Gradient f√ºr die Zahl
      const textGrad = ctx.createLinearGradient(40, 20, 88, 108);
      textGrad.addColorStop(0, '#f0f0f0');
      textGrad.addColorStop(0.3, '#c0c8d0');
      textGrad.addColorStop(0.5, '#e8ecf0');
      textGrad.addColorStop(0.7, '#a8b0b8');
      textGrad.addColorStop(1, '#d0d8e0');
      ctx.fillStyle = textGrad;
      ctx.fillText(n.toString(), 64, 62);
      
      // Glanz-Highlight oben
      ctx.shadowColor = 'transparent';
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffffff';
      ctx.fillText(n.toString(), 64, 60);
      ctx.restore();
      
      indicator.tex.needsUpdate = true;
    }
    
    function updateTapIndicators() {
      const off = 0.234375; // cubeSize/2
      const QC = {
        0: { x: -off, z: 0.109375 - off },
        1: { x:  off, z: 0.109375 - off },
        2: { x:  off, z: 0.109375 + off },
        3: { x: -off, z: 0.109375 + off }
      };
      const adj = ADJACENT_Q[currentQuadrant];
      const qA = QC[adj[0]];
      const qB = QC[adj[1]];
      
      tapIndicatorA.mesh.position.set(qA.x, tapIndicatorY, qA.z);
      tapIndicatorB.mesh.position.set(qB.x, tapIndicatorY, qB.z);
      
      drawTapIndicator(tapIndicatorA, tapCount);
      drawTapIndicator(tapIndicatorB, tapCount);
      
      tapIndicatorA.mesh.visible = tapCount > 0;
      tapIndicatorB.mesh.visible = tapCount > 0;
    }
    // =========================
    // GRADIENT SCHATTEN √úBER K√ÑRTCHEN
    // =========================
    // K√§rtchen: X ¬±0.625, Z von 0.734375 bis 1.046875
    const shadowGradCanvas = document.createElement('canvas');
    shadowGradCanvas.width = 512;
    shadowGradCanvas.height = 512;
    const sgCtx = shadowGradCanvas.getContext('2d');
    const grad = sgCtx.createLinearGradient(0, 0, 0, 512); // oben nach unten
    grad.addColorStop(0, 'rgba(0, 0, 0, 0.5)');   // Nord: schwarz
    grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)'); // Mitte: transparent
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.0)');   // S√ºd: transparent
    sgCtx.fillStyle = grad;
    sgCtx.fillRect(0, 0, 512, 512);

    const shadowGradTexture = new THREE.CanvasTexture(shadowGradCanvas);
    const shadowGradW = 1.25;    // 8 Zellen
    const shadowGradH = 0.3125;  // 2 Zellen = K√§rtchenh√∂he
    const shadowGradGeo = new THREE.PlaneGeometry(shadowGradW, shadowGradH);
    const shadowGradMat = new THREE.MeshBasicMaterial({ map: shadowGradTexture, transparent: true });
    const shadowGradPlane = new THREE.Mesh(shadowGradGeo, shadowGradMat);
    shadowGradPlane.rotation.x = -Math.PI / 2;
    shadowGradPlane.position.set(0, 0.001 + 3 * 0.15625 + 0.003, 0.890625); // auf Spieltisch
    shadowGradPlane.visible = false; // Schatten komplett entfernt
    scene.add(shadowGradPlane);


    // =========================
    // ACHSEN (X und Z)
    // =========================
    const axesMaterialPi1 = new THREE.LineBasicMaterial({ 
      color: 0xff8800, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });
    
    const axesMaterial = new THREE.LineBasicMaterial({ 
      color: 0xffffff, 
      linewidth: 2,
      opacity: 0.9,
      transparent: true
    });

    const xAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.002, 0.109375),
      new THREE.Vector3(2.5, 0.002, 0.109375)
    ]);
    const xAxis1 = new THREE.Line(xAxisGeometry1, axesMaterialPi1);
    xAxis1.visible = false;
    scene.add(xAxis1);

    const zAxisGeometry1 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.002, -2.5),
      new THREE.Vector3(0, 0.002, 2.5)
    ]);
    const zAxis1 = new THREE.Line(zAxisGeometry1, axesMaterialPi1);
    zAxis1.visible = false;
    scene.add(zAxis1);

    const xAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2.5, 0.46875, 0.109375),
      new THREE.Vector3(2.5, 0.46875, 0.109375)
    ]);
    const xAxis2 = new THREE.Line(xAxisGeometry2, axesMaterial);
    xAxis2.visible = false;
    scene.add(xAxis2);

    const zAxisGeometry2 = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.46875, -2.5),
      new THREE.Vector3(0, 0.46875, 2.5)
    ]);
    const zAxis2 = new THREE.Line(zAxisGeometry2, axesMaterial);
    zAxis2.visible = false;
    scene.add(zAxis2);

    // =========================
    // W√ÑNDE mit Metallwand-Textur
    // =========================
    const wallTexture = new THREE.TextureLoader().load('metallwand.webp');
    
    const wallGeometry = new THREE.BoxGeometry(0.9375, 0.46875, 0.0335);
    const wallMaterial = new THREE.MeshBasicMaterial({ 
      map: wallTexture,
      color: 0x666666  // Dunkler (40% Helligkeit)
    });
    
    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
    wall.position.set(0, 0.234375, 0.597125);
    wall.castShadow = false;
    wall.receiveShadow = true;
    scene.add(wall);

    const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
    wall2.position.set(0, 0.234375, -0.376125);
    wall2.castShadow = false;
    wall2.receiveShadow = true;
    scene.add(wall2);

    const sideWallGeometry = new THREE.BoxGeometry(0.0335, 0.46875, 1.00675);
    
    const wallLeft = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallLeft.position.set(-0.48550, 0.234375, 0.1105);
    wallLeft.castShadow = false;
    wallLeft.receiveShadow = true;
    scene.add(wallLeft);
    
    const wallRight = new THREE.Mesh(sideWallGeometry, wallMaterial);
    wallRight.position.set(0.48550, 0.234375, 0.1105);
    wallRight.castShadow = false;
    wallRight.receiveShadow = true;
    scene.add(wallRight);

    // =========================
    // SPIELTISCH TEXTUR (ersetzt codierten Rahmen)
    // =========================
    let spieltisch = null;
    const SPIEL_WIDTH = 8 * 0.15625;
    
    new THREE.TextureLoader().load('spieltisch.webp', (texture) => {
      const imgAspect = texture.image.height / texture.image.width;
      const height = SPIEL_WIDTH * imgAspect;
      
      const spieltischGeometry = new THREE.PlaneGeometry(SPIEL_WIDTH, height);
      const spieltischMaterial = new THREE.MeshStandardMaterial({ 
        map: texture,
        transparent: true,
        roughness: 0.8,
        metalness: 0.2,
        depthWrite: true
      });
      spieltisch = new THREE.Mesh(spieltischGeometry, spieltischMaterial);
      
      spieltisch.rotation.x = -Math.PI / 2;
      
      // Position ABSOLUT FINAL
      const xCenter = -0.625 + SPIEL_WIDTH / 2;
      const zCenter = -0.828125 + height / 2;
      const yPos = 0.001 + 3 * 0.15625;
      
      spieltisch.position.set(xCenter, yPos, zCenter);
      spieltisch.receiveShadow = false;
      spieltisch.castShadow = false;
      spieltisch.renderOrder = 1;
      
      // Matrix komplett einfrieren
      spieltisch.matrixAutoUpdate = false;
      spieltisch.updateMatrix();
      
      // Direkt zu Scene hinzuf√ºgen
      scene.add(spieltisch);
      console.log('Spieltisch loaded at fixed position:', xCenter, yPos, zCenter);
    });

    // =========================
    // HAND-DEMO f√ºr Phase 1
    // =========================
    const handTexture = new THREE.TextureLoader().load('data:image/png;base64,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');
    const handWidth = 0.46875; // 3 Zellen (75% von 4x)
    const handGeometry = new THREE.PlaneGeometry(handWidth, handWidth);
    const handMaterial = new THREE.MeshBasicMaterial({ 
      map: handTexture,
      transparent: true,
      side: THREE.DoubleSide,
      alphaTest: 0.1
    });
    const handDemo = new THREE.Mesh(handGeometry, handMaterial);
    handDemo.rotation.x = -Math.PI / 2;
    // Position: Zeile 11 Oberlinie, Spalte A Mitte
    // Zeile 11 Oberlinie: -0.359375 + 7 * 0.15625 - 0.078125 = 0.656250
    handDemo.position.set(-0.625 + handWidth/2 + 0.15625, 0.001 + 3 * 0.15625 + 0.15, 0.656250 + 0.15625);
    const handOriginalPos = handDemo.position.clone(); // Ursprungsposition speichern
    handDemo.visible = false;
    scene.add(handDemo);

    // =========================
    // W√úRFEL mit 3x3 Grid-Textur
    // =========================
    // W√ºrfel-Textur WebP (f√ºr f0, f1, f2)
    const cubeTexImg = new Image();
    cubeTexImg.src = 'data:image/webp;base64,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';
    
    // Leere W√ºrfelfl√§chen-Textur f√ºr andere 3 Fl√§chen
    const leereWflTexture = new THREE.TextureLoader().load('leerewfl.webp');
    cubeTexImg.src = 'data:image/webp;base64,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';
    const cubeSize = 0.46875;

    // Randomdeck 1-12 mischen
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    const deck = shuffle([1,2,3,4,5,6,7,8,9,10,11,12]);

    // Slot-Zuordnung: welche Zelle auf welcher Face ‚Üí deck-Index
    // f0: 7=S1, 4=S2, 2=S3, 3=S4
    // f1: 10=S1, 11=S2, 15=S3, 18=S4
    // f2: 27=S1, 26=S2, 22=S3, 19=S4
    // deck[0-3] ‚Üí f0 Slots, deck[4-7] ‚Üí f1 Slots, deck[8-11] ‚Üí f2 Slots

    // Canvas-Textur: 3x3 Gitter, slotMap = { "row,col": { val, rot } }
    function createFaceTexture(slotMap, imgRotation) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const cell = 256 / 3;

      // W√ºrfel-Textur als Hintergrund (optional rotiert, S√§ttigung reduziert)
      ctx.save();
      ctx.translate(128, 128);
      if (imgRotation) ctx.rotate(imgRotation);
      ctx.drawImage(cubeTexImg, -128, -128, 256, 256);
      ctx.restore();
      
      // Kontrast reduzieren mit semi-transparentem Overlay
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fillRect(0, 0, 256, 256);

      // Slot-Zellen beschriften
      ctx.fillStyle = '#2a1810';
      ctx.font = 'bold 56px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const key in slotMap) {
        const [r, c] = key.split(',').map(Number);
        const { val, rot } = slotMap[key];
        const cx = c * cell + cell / 2;
        const cy = r * cell + cell / 2;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        // Zweistellige Zahlen leicht nach links f√ºr optische Zentrierung
        const xOff = val >= 10 ? -4 : 0;
        ctx.fillText(val.toString(), xOff, 0);
        // Punkt bei 6 und 9: Satzpunkt nach der Zahl, gleiche Baseline
        if (val === 6 || val === 9) {
          ctx.beginPath();
          ctx.arc(xOff + 22, 18, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Rand
      ctx.strokeStyle = '#6b5040';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, 250, 250);

      return canvas;
    }

    function mat(slotMap, imgRotation) {
      return new THREE.MeshStandardMaterial({
        map: new THREE.CanvasTexture(createFaceTexture(slotMap || {}, imgRotation)),
        metalness: 0.3, roughness: 0.7
      });
    }

    // Material-Array: [+X, -X, +Y, -Y, +Z, -Z]
    // Rotationen per-Slot:
    // f2 (+Y): S1,S2 von S√ºden lesbar (0), S3,S4 von Westen lesbar (-œÄ/2)
    // f0 (+Z): S1,S2 von Westen lesbar (-œÄ/2), S3,S4 stehen Kopf (œÄ)
    // f1 (-X): S1,S2 stehen Kopf (œÄ), S3,S4 von S√ºden lesbar (œÄ/2)
    let cubeMaterial = [];
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const offset = cubeSize / 2;

    // =========================
    // KANTEN-KIPP-W√úRFEL
    // =========================
    const kipGroup = new THREE.Group();
    kipGroup.visible = true;
    scene.add(kipGroup);
    
    const cube = new THREE.Mesh(cubeGeometry, []);
    cube.position.set(-offset, offset, 0.109375 + offset);
    cube.castShadow = true;
    cube.receiveShadow = true;
    kipGroup.add(cube);

    // Materialien erst wenn Textur-Image geladen
    cubeTexImg.onload = function() {
      cubeMaterial = [
        mat(null),            // [0] +X  ‚Äì leer
        mat({                 // [1] -X  = f1
          '0,0': { val: deck[4],  rot: Math.PI },
          '0,1': { val: deck[5],  rot: Math.PI },
          '1,2': { val: deck[6],  rot: -Math.PI / 2 },
          '2,2': { val: deck[7],  rot: -Math.PI / 2 }
        }, Math.PI / 2),
        mat({                 // [2] +Y  = f2
          '2,2': { val: deck[8],  rot: 0 },
          '2,1': { val: deck[9],  rot: 0 },
          '1,0': { val: deck[10], rot: Math.PI / 2 },
          '0,0': { val: deck[11], rot: Math.PI / 2 }
        }, -Math.PI / 2),
        mat(null),            // [3] -Y  ‚Äì leer
        mat({                 // [4] +Z  = f0
          '2,0': { val: deck[0],  rot: Math.PI / 2 },
          '1,0': { val: deck[1],  rot: Math.PI / 2 },
          '0,1': { val: deck[2],  rot: Math.PI },
          '0,2': { val: deck[3],  rot: Math.PI }
        }),
        mat(null)             // [5] -Z  ‚Äì leer
      ];
      cube.material = cubeMaterial;
    };

    // =========================
    // 2D-TIMING SYSTEM
    // =========================
    const FIXED_SPEED = 3;
    const TARGET_MIN = 0.55;
    const STEP_MAX = 0.80;
    let targetTimeMul = 1;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function getTiming() {
      const v = FIXED_SPEED;
      const baseHold = Math.max(520, Math.round(2400 - v * 450));
      const baseKip = Math.max(160, Math.round(baseHold * 0.50));
      const baseW = baseHold;
      
      const mul = Math.max(TARGET_MIN, Math.min(1, targetTimeMul));
      
      const hold = Math.max(260, Math.round(baseHold * mul));
      const kip = Math.max(120, Math.round(baseKip * mul));
      const wfull = Math.max(260, Math.round(baseW * mul));
      
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    // =========================
    // UI ELEMENTS
    // =========================
    const hintText = document.getElementById('hintText');
    const countdown = document.getElementById('countdown');
    const actionButton = document.getElementById('actionButton');
    const backButton = document.getElementById('backButton');
    const resetButton = document.getElementById('resetButton');
    const kippButtons = document.getElementById('kippButtons');
    
    // WICHTIG: Button disabled bis Texturen geladen sind
    actionButton.disabled = true;

    // =========================
    // SPIELLOGIK: Treffer-Pr√ºfung
    // =========================
    let topFace = 'f2'; // Anfangslage beim Spieleintritt

    function advanceTopFace() {
      const cw  = { f2: 'f0', f0: 'f1', f1: 'f2' };
      const ccw = { f2: 'f1', f1: 'f0', f0: 'f2' };
      const oldFace = topFace;
      topFace = (kippDirection === 'cw') ? cw[topFace] : ccw[topFace];
      console.log('advanceTopFace:', oldFace, '‚Üí', topFace, 'dir:', kippDirection, 'Q:', currentQuadrant);
    }

    // Welche Nachbarfarbe hat jeder Slot pro Quadrant
    const SLOT_NEIGHBOR_COLORS = {
      0: { S1: 'blau',    S2: 'violett', S3: 'gruen',   S4: 'orange'  },
      1: { S1: 'orange',  S2: 'blau',    S3: 'violett', S4: 'gruen'   },
      2: { S1: 'gruen',   S2: 'orange',  S3: 'blau',    S4: 'violett' },
      3: { S1: 'violett', S2: 'gruen',   S3: 'orange',  S4: 'blau'    }
    };

    // Zielkreis-Positionen pro Quadrant (3D-Koordinaten)
    const KIPP_TARGET_POS_3D = {
      0: new THREE.Vector3(-0.15625, 0.48, -0.046875),  // Q0 NW: Zeilen 5/6, Spalten C/D
      1: new THREE.Vector3( 0.15625, 0.48, -0.046875),  // Q1 NE: Zeilen 5/6, Spalten E/F
      2: new THREE.Vector3( 0.15625, 0.48,  0.265625),  // Q2 SE: Zeilen 7/8, Spalten E/F
      3: new THREE.Vector3(-0.15625, 0.48,  0.265625)   // Q3 SW: Zeilen 7/8, Spalten C/D
    };

    function updateKippTargetPosition() {
      const pos3D = KIPP_TARGET_POS_3D[currentQuadrant].clone();
      pos3D.project(camera);
      const targetEl = document.getElementById('kippTarget');
      targetEl.style.left = ((pos3D.x * 0.5 + 0.5) * 360) + 'px';
      targetEl.style.top = ((-pos3D.y * 0.5 + 0.5) * 720) + 'px';
    }

    // 4 Farbfelder pro Quadrant (f√ºr Nicht-Treffer-Animation)
    const QUADRANT_COLORS = {
      0: ['Nord_C', 'Nord_D', 'West_5', 'West_6'],
      1: ['Nord_E', 'Nord_F', 'Ost_5',  'Ost_6'],
      2: ['S√ºd_E',  'S√ºd_F',  'Ost_7',  'Ost_8'],
      3: ['S√ºd_C',  'S√ºd_D',  'West_7', 'West_8']
    };

    // Material-Index pro Face (BoxGeometry: [+X,-X,+Y,-Y,+Z,-Z])
    const TOP_FACE_MAT_IDX = { f0: 4, f1: 1, f2: 2 };

    // Des√§tturierte Versionen der Spielfarben f√ºr das K√§rtchen
    const DESAT_COLORS = {
      violett: '#6b5a6b',
      blau:    '#5a6b7b',
      gruen:   '#5b7b6b',
      orange:  '#7b6b5a'
    };

    function checkTreffer() {
      const card = gameCards[activeCardIdx];
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };

      // Ist card.zahl sichtbar?
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === card.zahl) { hitSlot = slot; break; }
      }
      if (!hitSlot) return false;

      // Nachbarfarbe pr√ºfen
      const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
      return neighborColor === card.color.name;
    }

    // Generische Animation eines Wertes √ºber Zeit
    function animateVal(from, to, duration, onUpdate, onFinish) {
      const start = performance.now();
      function tick(now) {
        const t = Math.min((now - start) / duration, 1);
        const eased = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
        onUpdate(from + (to - from) * eased);
        if (t < 1) requestAnimationFrame(tick);
        else if (onFinish) onFinish();
      }
      requestAnimationFrame(tick);
    }

    let activeCardIdx = 0;
    const bereitsGetroffen = new Set(); // "zahl_farbe" Kombinationen die bereits Treffer waren
    const bereitsAusgegeben = new Set(); // "zahl_farbe" Kombinationen die bereits als Ziel ausgegeben wurden
    
    const GAME_COLORS = [
      { name: 'violett', hex: '#a41b85' },
      { name: 'blau',    hex: '#006bb3' },
      { name: 'gruen',   hex: '#00a652' },
      { name: 'orange',  hex: '#e67814' }
    ];

    // === Offene Kippziele: genau 2 von 6 haben eine Zahl, die in der aktuellen Ausgangslage sichtbar ist ===
    function pickTwoRandomPositions() {
      const all = [0, 1, 2, 3, 4, 5];
      for (let i = all.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [all[i], all[j]] = [all[j], all[i]];
      }
      return new Set([all[0], all[1]]);
    }
    let openKippzielPositions = pickTwoRandomPositions();
    let offeneKippzieleVergeben = 0; // Z√§hlt wie viele offene bereits generiert wurden
    let isReplay = false; // Nach "Neues Spiel" ‚Üí kein Erkl√§rtext

    // Aktuell sichtbare Zahlen auf der Oberseite ermitteln (aus aktuellem topFace)
    function getCurrentVisibleZahlen() {
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      return new Set([deck[off], deck[off+1], deck[off+2], deck[off+3]]);
    }

    function fillCardWithKombi(idx, zahl, colorObj) {
      const card = gameCards[idx];
      
      // Zahl und Farbe im Card-Object speichern
      card.zahl = zahl;
      card.color = colorObj;
      
      // Farb-Image auf Canvas zeichnen
      const img = colorTargetImages[colorObj.name];
      if (!img) {
        console.error(`Image ${colorObj.name} not loaded!`);
        return;
      }
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      // Zahl 42px unter Oberkante
      const displayText = zahl + ((zahl === 6 || zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.visible = true; // K√§rtchen sichtbar machen
      
      // Kombi als ausgegeben markieren
      bereitsAusgegeben.add(zahl + '_' + colorObj.name);
    }
    
    function drawGoldenBorder(card) {
      // CMYK: 18, 20, 85, 3 ‚Üí RGB: #cedb25
      card.ctx.strokeStyle = '#cedb25';
      card.ctx.lineWidth = 4;
      card.ctx.strokeRect(2, 2, 85 - 4, 170 - 4);
      card.texture.needsUpdate = true;
      
      // Markieren dass dieses K√§rtchen ein Treffer ist
      card.isHit = true;
    }
    

    function generateNeueKombiOhne(ausschlussSet, zahlenFilter, visibleZahlen) {
      // zahlenFilter: 'open' = nur sichtbare Zahlen, 'closed' = nur NICHT sichtbare, undefined = alle
      // visibleZahlen: Set der aktuell sichtbaren Zahlen (nur n√∂tig wenn zahlenFilter gesetzt)
      const alleMoeglichenKombis = [];
      for (let z = 1; z <= 12; z++) {
        if (zahlenFilter === 'open' && visibleZahlen && !visibleZahlen.has(z)) continue;
        if (zahlenFilter === 'closed' && visibleZahlen && visibleZahlen.has(z)) continue;
        
        for (const colorObj of GAME_COLORS) {
          const key = z + '_' + colorObj.name;
          if (!bereitsAusgegeben.has(key) && !ausschlussSet.has(key)) {
            alleMoeglichenKombis.push({ zahl: z, color: colorObj });
          }
        }
      }
      
      if (alleMoeglichenKombis.length === 0) return null;
      
      const idx = Math.floor(Math.random() * alleMoeglichenKombis.length);
      return alleMoeglichenKombis[idx];
    }

    function getCurrentErfuellteKombis() {
      // Aktuelle W√ºrfellage ermitteln und erf√ºllte Kombis zur√ºckgeben
      const faceOffset = { f0: 0, f1: 4, f2: 8 };
      const off = faceOffset[topFace];
      const erfuellteKombis = new Set();
      const slots = ['S1', 'S2', 'S3', 'S4'];
      slots.forEach((slot, i) => {
        const zahl = deck[off + i];
        const farbe = SLOT_NEIGHBOR_COLORS[currentQuadrant][slot];
        erfuellteKombis.add(zahl + '_' + farbe);
      });
      return erfuellteKombis;
    }


    function onRunde() {
      activeCardIdx++;
      
      // Nach 6 Versuchen: Spielende
      if (activeCardIdx >= 6) {
        showGameEnd();
        return;
      }
      
      // ERST: NEUES K√ÑRTCHEN GENERIEREN
      if (activeCardIdx < 6) {
        const erfuellteKombis = getCurrentErfuellteKombis();
        const visibleZahlen = getCurrentVisibleZahlen();
        let zahlenFilter;
        if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
          zahlenFilter = 'open';
        } else {
          zahlenFilter = 'closed';
        }
        let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
        if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis); // Fallback
        if (neueKombi) {
          if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
          fillCardWithKombi(activeCardIdx, neueKombi.zahl, neueKombi.color);
        }
      }
      
      // DANN: Pause-Check (√úBERSPRUNGEN - Pause-Phase deaktiviert)
      // if (activeCardIdx === 3) {
      //   setButtonsDisabled(true);
      //   document.getElementById('richtungButtons').classList.add('hidden');
      //   kippButtons.classList.add('hidden');
      //   savedCubePosition = cube.position.clone();
      //   savedCubeQuaternion = cube.quaternion.clone();
      //   savedTopFace = topFace;
      //   savedCurrentQuadrant = currentQuadrant;
      //   animateAufEcke().then(() => {
      //     startPausePhase();
      //   });
      //   return;
      // }
      
      // Weiterspielen
      setButtonsDisabled(false);
    }
    
    function calculateBrainScore(observationTime, hits) {
      // Constants
      const FREE_TIME = 20;
      const MAX_TIME = 120;
      const EXTRA_TIME_RANGE = 100; // MAX_TIME - FREE_TIME
      const k = 1.0;
      const c = 2.5976583;
      
      // Special case: no hits
      if (hits === 0) {
        return "No Hit, no Score";
      }
      
      // Clamp observation time
      let T = observationTime;
      if (T < FREE_TIME) T = FREE_TIME;
      if (T > MAX_TIME) T = MAX_TIME;
      
      // Time Factor
      const E = Math.max(0, Math.min(T - FREE_TIME, EXTRA_TIME_RANGE));
      const S_time = 1 - 0.31 * Math.pow(E / EXTRA_TIME_RANGE, 0.855);
      
      // Hit Factor (logistic)
      const L = (H) => 1 / (1 + Math.exp(-k * (H - c)));
      const S_hits = L(hits) / L(6);
      
      // Final Brain Score
      const brainScore = 100 * S_time * S_hits;
      
      // Formatierung: 1 Kommastelle mit %, au√üer bei 100%
      if (Math.abs(brainScore - 100) < 0.05) {
        return "100%";
      } else {
        return brainScore.toFixed(1).replace('.', ',') + '%';
      }
    }
    
    function showGameEnd() {
      gamePhase = 'ende';
      setButtonsDisabled(true);
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      document.getElementById('kippTarget').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      countdown.style.display = 'none';
      resetButton.style.display = 'none';
      
      // Wie viele Treffer?
      const treffer = bereitsGetroffen.size;
      
      // Brain Score berechnen
      const scoreValue = calculateBrainScore(totalObservationTime, treffer);
      
      // hintText verstecken
      hintText.style.display = 'none';
      
      // Brain Score anzeigen
      const brainScore = document.getElementById('brainScore');
      if (scoreValue === "No Hit, no Score") {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">BRAIN SCORE:<br>No Hit, no Score</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + treffer + ' HITS | ' + totalObservationTime + ' SCHAU-Sekunden</span>';
      } else {
        brainScore.innerHTML = '<span style="font-size:12pt;font-weight:bold;">BRAIN SCORE: ' + scoreValue + '</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">Best: 100% | Worst: 12%</span>' +
          '<br><span style="font-size:10pt;font-weight:normal;">' + treffer + ' HITS | ' + totalObservationTime + ' SCHAU-Sekunden</span>';
      }
      brainScore.style.display = 'block';
      brainScore.style.opacity = '1';
      
      // "Neues Spiel" Button anzeigen (Position wie Auge/Timer/weiter)
      actionButton.textContent = 'Neues Spiel';
      actionButton.style.display = 'block';
      actionButton.style.opacity = '1';
      if (timerTopPos) {
        actionButton.style.top = timerTopPos;
      }
      actionButton.style.left = '180px';
      actionButton.disabled = false;
    }


    // Array zum Speichern der urspr√ºnglichen opacity-Werte
    const savedCardOpacities = [];

    function startPausePhase() {
      gamePhase = 'pause';
      pauseExiting = false;
      document.getElementById('kippTarget').style.display = 'none';

      // Aktuelle opacity aller 6 K√§rtchen speichern
      savedCardOpacities.length = 0;
      gameCards.forEach(c => {
        savedCardOpacities.push(c.mesh.material.opacity);
        c.mesh.material.transparent = true;
        c.mesh.material.needsUpdate = true;
      });
      
      shadowGradPlane.material.transparent = true;
      shadowGradPlane.material.needsUpdate = true;
      shadowGradPlane.material.opacity = 1;

      // Alle 6 K√§rtchen auf opacity 0 animieren
      const startOpacities = savedCardOpacities.slice();
      animateVal(1, 0, 350, (t) => {
        gameCards.forEach((c, i) => { 
          c.mesh.material.opacity = startOpacities[i] * t; 
        });
        shadowGradPlane.material.opacity = t;
      }, () => {
        // K√§rtchen komplett ausblenden
        gameCards.forEach(c => c.mesh.visible = false);
        pauseLights.forEach(l => l.visible = true);

        // Pause-Pivot auf der Ecke erstellen
        const cornerPos = new THREE.Vector3(0, 0, 0.109375);
        pausePivotGroup = new THREE.Group();
        pausePivotGroup.position.copy(cornerPos);
        kipGroup.add(pausePivotGroup);

        cube.updateMatrixWorld();
        const wp = new THREE.Vector3();
        cube.getWorldPosition(wp);
        const wq = new THREE.Quaternion();
        cube.getWorldQuaternion(wq);

        kipGroup.remove(cube);
        cube.position.copy(wp.clone().sub(cornerPos));
        cube.quaternion.copy(wq);
        pausePivotGroup.add(cube);

        pauseAlpha = 0;
        pauseBeta  = 0;
        pauseDragActive = false;

        // UI faden ein (ohne Text)
        hintText.style.display = 'none';
        actionButton.textContent = 'weiter';
        actionButton.style.opacity = '0';
        actionButton.style.display = 'block';

        // requestAnimationFrame damit display:block erstmal greift
        requestAnimationFrame(() => {
          actionButton.style.transition = 'opacity 0.4s ease';
          actionButton.style.opacity = '1';
        });
      });
    }

    function endPausePhase() {
      if (pauseExiting) return;
      pauseExiting = true;
      pauseSpringRunning = false;
      pauseDragActive = false;
      if (pauseTimerRef) { clearInterval(pauseTimerRef); pauseTimerRef = null; }

      // UI faden aus
      hintText.style.transition = 'opacity 0.35s ease';
      actionButton.style.transition = 'opacity 0.35s ease';
      hintText.style.opacity = '0';
      actionButton.style.opacity = '0';
      setTimeout(() => {
        hintText.style.display = 'none';
        actionButton.style.display = 'none';
      }, 350);

      // Schritt 1: Aufrichten von aktueller Position auf senkrecht (alpha=0, beta=0)
      const startAlpha = pauseAlpha;
      const startBeta  = pauseBeta;
      const aufrichtDur = 600;
      const aufrichtStart = Date.now();

      function animateAufrichten() {
        const elapsed = Date.now() - aufrichtStart;
        const progress = Math.min(elapsed / aufrichtDur, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        pauseAlpha = startAlpha * (1 - eased);
        pauseBeta  = startBeta  * (1 - eased);
        if (pausePivotGroup) pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');

        if (progress < 1) {
          requestAnimationFrame(animateAufrichten);
        } else {
          pauseAlpha = 0;
          pauseBeta  = 0;
          if (pausePivotGroup) pausePivotGroup.rotation.set(0, 0, 0, 'YXZ');
          // Schritt 2: Inverse aufEcke ‚Äî zur√ºck auf letzte Spielposition
          animateInverseAufEcke();
        }
      }
      animateAufrichten();
    }

    function animateInverseAufEcke() {
      const duration = 1200;
      const startTime = Date.now();
      const inverseQuat = aufEckeTargetQuat.clone().invert();

      function animateZur√ºck() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        const currentQuat = new THREE.Quaternion().slerp(inverseQuat, eased);
        if (pausePivotGroup) pausePivotGroup.quaternion.copy(currentQuat);

        if (progress < 1) {
          requestAnimationFrame(animateZur√ºck);
        } else {
          finishPauseToSpiel();
        }
      }
      animateZur√ºck();
    }

    async function animateAufEcke() {
      const cornerPos = new THREE.Vector3(0, 0, 0.109375); // Die feste Ecke
      const duration = 1200;

      // Cube aus kipGroup nehmen, in pivotGroup bei der Ecke platzieren
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(cornerPos);
      kipGroup.add(pivotGroup);

      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      const cubeWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(cubeWorldQuat);

      kipGroup.remove(cube);
      cube.position.copy(cubeWorldPos.clone().sub(cornerPos));
      cube.quaternion.copy(cubeWorldQuat);
      pivotGroup.add(cube);

      // Ziel-Rotation: Vektor von Ecke zum W√ºrfelmittelpunkt soll nach +Y zeigen
      const relativePos = cube.position.clone().normalize();
      const targetDir = new THREE.Vector3(0, 1, 0);
      const targetQuat = new THREE.Quaternion().setFromUnitVectors(relativePos, targetDir);
      aufEckeTargetQuat = targetQuat.clone();

      const startTime = Date.now();

      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          const currentQuat = new THREE.Quaternion().copy(new THREE.Quaternion()).slerp(targetQuat, eased);
          pivotGroup.quaternion.copy(currentQuat);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Cleanup: wie finalizeKipp
            cube.updateMatrixWorld();
            const newWorldPos = new THREE.Vector3();
            cube.getWorldPosition(newWorldPos);
            const newWorldQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newWorldQuat);

            pivotGroup.remove(cube);
            kipGroup.remove(pivotGroup);

            cube.position.copy(newWorldPos);
            cube.quaternion.copy(newWorldQuat);
            kipGroup.add(cube);

            resolve();
          }
        }
        animate();
      });
    }

    function animateTreffer() {
      const card = gameCards[activeCardIdx];
      const mesh = card.mesh;
      
      // Kurze Puls-Animation (3 Pulse)
      const pulseDuration = 200; // ms pro Puls
      const pulseCount = 3;
      let currentPulse = 0;
      
      function doPulse() {
        if (currentPulse >= pulseCount) {
          // Animation fertig - Rahmen hinzuf√ºgen
          drawGoldenBorder(card);
          
          // Weiter zur n√§chsten Runde (onRunde erh√∂ht activeCardIdx und generiert n√§chstes K√§rtchen)
          onRunde();
          return;
        }
        
        // Puls: 1.0 ‚Üí 1.15 ‚Üí 1.0
        const startTime = performance.now();
        function animatePulse(now) {
          const t = Math.min((now - startTime) / pulseDuration, 1);
          const scale = 1.0 + Math.sin(t * Math.PI) * 0.15;
          mesh.scale.set(scale, scale, scale);
          
          if (t < 1) {
            requestAnimationFrame(animatePulse);
          } else {
            mesh.scale.set(1, 1, 1);
            currentPulse++;
            setTimeout(doPulse, 100); // Kurze Pause zwischen Pulsen
          }
        }
        requestAnimationFrame(animatePulse);
      }
      
      doPulse();
    }

    function animateNichtTreffer() {
      const card = gameCards[activeCardIdx];
      
      // Aktuelles K√§rtchen durch leernohit ersetzen
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(leerImage, 0, 0, 85, 170);
      card.texture.needsUpdate = true;
      
      // Auf 60% transparent setzen
      card.mesh.material.transparent = true;
      card.mesh.material.opacity = 0.6;
      card.mesh.material.needsUpdate = true;
      
      // Markieren als gespielt (Nicht-Treffer) und zahl/color l√∂schen
      card.zahl = null;
      card.color = null;
      card.isMiss = true;
      
      // Weiter zur n√§chsten Runde (onRunde erh√∂ht activeCardIdx und generiert n√§chstes K√§rtchen)
      onRunde();
    }

    let gamePhase = 'spielziel';
    let currentMode = 'kanten';
    let kippCount = 0;
    let liegeZeiten = [];
    let liegeStartTime = null;
    let autoEvalTimeout = null;
    let countdownTimer = null;

    // UI f√ºr Demo-Phase initialisieren
    hintText.textContent = ''; // Leer lassen - Text-Sequenz √ºbernimmt
    actionButton.style.display = 'none';
    countdown.style.display = 'none';
    
    // Flag um Demo-Animation abbrechen zu k√∂nnen
    let isDemoAnimating = false;
    
    function startCountdown(onFinish, maxTime) {
      let timeElapsed = 0;
      countdown.textContent = timeElapsed;
      countdown.style.display = 'block';
      if (timerTopPos) countdown.style.top = timerTopPos;
      countdown.style.left = '180px';
      
      countdownTimer = setInterval(() => {
        timeElapsed++;
        totalObservationTime++;
        countdown.textContent = timeElapsed;
        if (maxTime && timeElapsed >= maxTime) {
          stopCountdown();
          countdown.style.display = 'none';
          if (onFinish) onFinish();
        }
      }, 1000);
    }
    
    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }
    
    // Timer deaktiviert
    let timerStarted = false;

    // =========================
    // DEMO-ANIMATION Phase 1
    // =========================
    
    function showTextAtWobble() {
      // Text-Animation deaktiviert
    }
    
    function startDemoAnimation() {
      // Hand auf Ursprungsposition zur√ºcksetzen
      handDemo.position.copy(handOriginalPos);
      handDemo.visible = true;
      handDemo.rotation.z = 0; // Initial keine Drehung
      
      const cubeStart = cube.position.clone();
      const cubeStartRot = cube.quaternion.clone();
      const handStart = handDemo.position.clone();
      
      const wippAngle = 20 * Math.PI / 180; // 20¬∞ Aufkipp-Winkel
      const wippDuration = 800; // ms pro Wipp
      const pauseBetween = 250; // ms Pause zwischen Wipps (reduziert)
      
      // Wipp Richtung Q0 (Nord, um X-Achse)
      function wippNord() {
        return new Promise(resolve => {
          isDemoAnimating = true;
          showTextAtWobble(); // Text genau beim Wobble-Start
          const startTime = performance.now();
          function animateWippNord(currentTime) {
            if (!isDemoAnimating) {
              resolve();
              return;
            }
            const elapsed = currentTime - startTime;
            const t = Math.min(elapsed / wippDuration, 1);
            const angle = Math.sin(t * Math.PI) * wippAngle; // Hin und zur√ºck
            
            // W√ºrfel wippen
            cube.quaternion.copy(cubeStartRot);
            cube.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -angle)); // Negativ f√ºr Nord
            
            // Hand synchron bewegen (z-Richtung, nach hinten/Nord)
            const handOffset = Math.sin(t * Math.PI) * 0.1;
            handDemo.position.z = handStart.z - handOffset; // Nach Nord (kleinerer z-Wert)
            
            if (t < 1) {
              requestAnimationFrame(animateWippNord);
            } else {
              // Zur√ºck zur Ausgangslage
              cube.quaternion.copy(cubeStartRot);
              cube.position.copy(cubeStart);
              handDemo.position.copy(handStart);
              handDemo.rotation.z = 0; // Rotation zur√ºcksetzen
              isDemoAnimating = false;
              setTimeout(resolve, pauseBetween);
            }
          }
          requestAnimationFrame(animateWippNord);
        });
      }
      
      // Wipp Richtung Q2 (Ost, um Z-Achse)
      function wippOst() {
        return new Promise(resolve => {
          isDemoAnimating = true;
          showTextAtWobble(); // Text genau beim Wobble-Start
          // Hand f√ºr Ost-Kipp neu positionieren (3 Zellen n√∂rdlicher, 2.77 Zellen westlicher)
          const handQ2PosZ = handStart.z - 0.46875;
          const handQ2PosX = handStart.x - 0.43375;
          handDemo.position.set(handQ2PosX, handDemo.position.y, handQ2PosZ);
          const handStartQ2 = handDemo.position.clone();
          handDemo.rotation.z = -Math.PI / 2; // 90¬∞ cw gedreht
          
          const startTime = performance.now();
          function animateWippOst(currentTime) {
            if (!isDemoAnimating) {
              resolve();
              return;
            }
            const elapsed = currentTime - startTime;
            const t = Math.min(elapsed / wippDuration, 1);
            const angle = Math.sin(t * Math.PI) * wippAngle;
            
            // W√ºrfel wippen
            cube.quaternion.copy(cubeStartRot);
            cube.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -angle));
            
            // Hand synchron bewegen (x-Richtung, nach rechts)
            const handOffset = Math.sin(t * Math.PI) * 0.1;
            handDemo.position.x = handStartQ2.x + handOffset;
            
            if (t < 1) {
              requestAnimationFrame(animateWippOst);
            } else {
              // Zur√ºck zur Ausgangslage
              cube.quaternion.copy(cubeStartRot);
              cube.position.copy(cubeStart);
              handDemo.position.copy(handStart); // Zur√ºck zur Original-Position!
              handDemo.rotation.z = 0; // Rotation zur√ºcksetzen
              isDemoAnimating = false;
              setTimeout(resolve, pauseBetween);
            }
          }
          requestAnimationFrame(animateWippOst);
        });
      }
      
      // Demo-Loop: Wobbles immer N-O-N, dann Pause, wieder N-O-N...
      function demoLoop() {
        if (gamePhase !== 'demo') {
          handDemo.visible = false;
          return;
        }
        
        // Immer N ‚Üí O ‚Üí N
        wippNord()
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            return wippOst();
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            // Pause zwischen "SCHAUEN" und "MERKEN": +0,4 Sek (reduziert)
            return new Promise(resolve => setTimeout(resolve, 400));
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return Promise.reject('demo ended');
            }
            return wippNord();
          })
          .then(() => {
            if (gamePhase !== 'demo') {
              handDemo.visible = false;
              return;
            }
            // 3 Wobbles/Texte durch ‚Üí Hand ausblenden f√ºr Pause
            handDemo.visible = false;
            
            // Pause 1,5s, dann n√§chster Zyklus (reduziert)
            setTimeout(() => {
              if (gamePhase === 'demo') {
                // Hand zur√ºcksetzen und wieder sichtbar machen
                handDemo.position.copy(handStart);
                handDemo.rotation.z = 0;
                handDemo.visible = true;
                demoLoop(); // N√§chster Zyklus
              }
            }, 1500);
          })
          .catch(() => {
            // Demo wurde abgebrochen
          });
      }
      
      demoLoop();
    }
    
    // Demo starten nach kurzer Verz√∂gerung (reduziert)
    setTimeout(() => {
      if (gamePhase === 'demo') {
        startDemoAnimation(); // Texte erscheinen automatisch bei Wobbles
      }
    }, 600);
    
    // === PHASE 1: SPIEL ZIEL ===
    // Farbnamen f√ºr Tutorial-Anzeige
    const FARB_DISPLAY = {
      'violett': 'Violett', 'blau': 'Blau', 'gruen': 'Gr√ºn', 'orange': 'Orange'
    };
    
    // Beispiel-Kippziel aus aktueller W√ºrfellage (Q3, f2 oben) generieren
    function initSpielzielPhase() {
      // Bei Replay: Spielziel √ºberspringen, direkt zur Entscheidung
      if (isReplay) {
        initEntscheidungPhase();
        return;
      }
      
      // Zuf√§lligen Slot w√§hlen (S1-S4)
      const slotIdx = Math.floor(Math.random() * 4);
      const slotNames = ['S1', 'S2', 'S3', 'S4'];
      const beispielZahl = deck[8 + slotIdx]; // f2 offset = 8
      const beispielFarbe = SLOT_NEIGHBOR_COLORS[3][slotNames[slotIdx]]; // Q3
      const farbDisplay = FARB_DISPLAY[beispielFarbe] || beispielFarbe;
      
      // Beispiel-Kippziel auf verdecktesMesh zeichnen
      function drawBeispiel() {
        if (!texturesReady || !colorTargetImages[beispielFarbe]) {
          setTimeout(drawBeispiel, 50);
          return;
        }
        const img = colorTargetImages[beispielFarbe];
        verdecktesCtx.clearRect(0, 0, 85, 170);
        verdecktesCtx.drawImage(img, 0, 0, 85, 170);
        const displayText = beispielZahl + ((beispielZahl === 6 || beispielZahl === 9) ? '.' : '');
        verdecktesCtx.fillStyle = '#2a1810';
        verdecktesCtx.font = 'bold 56px Arial';
        verdecktesCtx.textAlign = 'center';
        verdecktesCtx.textBaseline = 'middle';
        verdecktesCtx.fillText(displayText, 42, 42);
        verdecktesCanvasTex.needsUpdate = true;
      }
      drawBeispiel();
      
      // Mesh sichtbar, kein Puls
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Texte
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      const szText = document.getElementById('spielZielText');
      szText.innerHTML = '<b>SPIEL ZIEL</b><br>' +
        '‚Ä¢ Finde m√∂glichst oft die richtige Kipp-Anzahl und -Richtung heraus, damit der W√ºrfel das Kippziel trifft. Hier z.B. <b>' + beispielZahl + '</b> an <b>' + farbDisplay + '</b>.<br>' +
        'Es sind nie mehr als <b>6</b> Kipps, wenn die Richtung stimmt.<br>' +
        '‚Ä¢ Nutze <b>SCHAU</b>-Sek. effektiv.';
      szText.style.display = 'block';
      
      // weiter-Button zentriert unter Text positionieren
      actionButton.textContent = 'weiter';
      actionButton.disabled = false;
      actionButton.style.display = 'block';
      actionButton.style.opacity = '1';
      setTimeout(() => {
        const szRect = szText.getBoundingClientRect();
        const containerRect = renderer.domElement.getBoundingClientRect();
        const topVal = (szRect.bottom - containerRect.top + 32) + 'px';
        actionButton.style.top = topVal;
        actionButton.style.left = '180px';
        timerTopPos = topVal; // Position f√ºr alle Timer merken
      }, 10);
    }
    let timerTopPos = null;
    // Direkt SCHAUEN-Phase starten (SPIEL ZIEL √ºberspringen f√ºr Preview)
    initSpielzielPhase();
    
    // === ENTSCHEIDUNGS-PHASE ===
    function initEntscheidungPhase() {
      gamePhase = 'entscheidung';
      
      // SpielZiel-Text ausblenden
      document.getElementById('spielZielText').style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      
      // Reset-Button zeigen
      resetButton.style.display = 'block';
      const resetPos3D = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      resetPos3D.project(camera);
      const resetScreenX = (resetPos3D.x * 0.5 + 0.5) * 360;
      const resetScreenY = (-resetPos3D.y * 0.5 + 0.5) * 720;
      resetButton.style.left = resetScreenX + 'px';
      resetButton.style.top = (resetScreenY - 22 - 6) + 'px';
      
      // W√ºrfel in Q3, ruhig liegend (kein Reset n√∂tig - steht schon)
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      // Verdecktes K√§rtchen pulsierend - IMMER auf linkeste Position (Index 0) zur√ºcksetzen
      verdecktesMesh.position.set(cardStartX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Augen-Icon UNTER dem verdeckten Kippziel positionieren
      const eyeIcon = document.getElementById('eyeIcon');
      const vkPos = new THREE.Vector3().copy(verdecktesMesh.position);
      vkPos.project(camera);
      const vkScreenY = (-vkPos.y * 0.5 + 0.5) * 720;
      eyeIcon.style.top = (vkScreenY + 55) + 'px'; // 55px unter Kippziel-Mitte
      eyeIcon.style.display = 'block';
      
      // Entscheidungs-Text nur beim ersten Mal zeigen
      const etText = document.getElementById('entscheidungText');
      if (isReplay) {
        etText.style.display = 'none';
      } else {
        etText.innerHTML = '<b>IMMER 2 OPTIONEN</b><br>‚Ä¢ Zuerst auf Augen-Icon ‚Äì W√ºrfelschauen (empfohlen)<br>‚Ä¢ Gleich auf Kippziel ‚Äì Kippzug machen';
        etText.style.display = 'block';
      }
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }
    
    // Eye-Icon Click ‚Üí Schauen-Phase (Demo)
    const eyeEl = document.getElementById('eyeIcon');
    eyeEl.addEventListener('touchstart', (e) => {
      e.stopPropagation();
    }, { passive: false });
    eyeEl.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (gamePhase !== 'entscheidung') return;
      if (activeCardIdx === 0) {
        spielzielToDemoPhase();
      } else {
        startFreeSchauenPhase();
      }
    }, { passive: false });
    eyeEl.addEventListener('click', (e) => {
      e.stopPropagation();
      if (gamePhase !== 'entscheidung') return;
      if (activeCardIdx === 0) {
        spielzielToDemoPhase();
      } else {
        startFreeSchauenPhase();
      }
    });
    
    // Spielziel ‚Üí Demo √úbergang (jetzt von Entscheidung aufgerufen)
    function spielzielToDemoPhase() {
      gamePhase = 'demo';
      
      // Auge ausblenden, Timer zeigen
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      resetButton.style.display = 'block';
      const resetPos3D = new THREE.Vector3(-0.625, 0.46875, -0.828125 + 0.15625);
      resetPos3D.project(camera);
      const resetScreenX = (resetPos3D.x * 0.5 + 0.5) * 360;
      const resetScreenY = (-resetPos3D.y * 0.5 + 0.5) * 720;
      resetButton.style.left = resetScreenX + 'px';
      resetButton.style.top = (resetScreenY - 22 - 6) + 'px';
      
      // Unsichtbarer Spacer f√ºr Text-Umfluss um animierte 3D-Hand
      const instrText = document.getElementById('instructionText');
      if (!instrText.querySelector('.hand-spacer')) {
        const spacer = document.createElement('div');
        spacer.className = 'hand-spacer';
        instrText.insertBefore(spacer, instrText.firstChild);
      }
      instrText.style.display = isReplay ? 'none' : 'block';
      actionButton.style.display = 'none';
      
      // verdecktesMesh zur√ºck auf leernohit + Puls
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      
      // W√ºrfel resetten f√ºr Demo
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      
      // Demo starten
      startDemoAnimation();
      
      // SCHAUEN-Timer: nur "00" anzeigen, startet erst bei erstem Kipp
      countdown.textContent = '0';
      countdown.style.display = 'block';
      if (timerTopPos) countdown.style.top = timerTopPos;
      countdown.style.left = '180px';
    }
    
    function phaseKippenToSpielen() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      
      // W√ºrfel bleibt wo er in SCHAUEN war (kein Reset!)
      // topFace und currentQuadrant sind korrekt getrackt

      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons UNSICHTBAR und INAKTIV lassen
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zur√ºcksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Tutorial-Text NUR in Runde 1
      const tutText = document.getElementById('tutorialText');
      if (activeCardIdx === 0 && erstesKippziel && !isReplay) {
        const zahl = erstesKippziel.zahl;
        const farbe = FARB_DISPLAY[erstesKippziel.color.name] || erstesKippziel.color.name;
        tutText.innerHTML = '<b>TIPPEN & SCHUBSEN</b><br>Das Kippziel links zeigt: <b>' + zahl + '</b> muss zu <b>' + farbe + '</b> gekippt werden.<br><b>TIPPE</b> ein- bis sechsmal auf den W√ºrfel.<br><b>SCHUBSE</b> ihn anschlie√üend in die gew√ºnschte Richtung, um den Kippzug auszul√∂sen.';
        tutText.style.display = 'block';
      } else {
        tutText.style.display = 'none';
      }
      
      // Zielscheibe positionieren basierend auf aktuellem Quadranten
      updateKippTargetPosition();
      const targetEl = document.getElementById('kippTarget');
      targetEl.style.display = 'block';
      
      // Kein Timer-Display in Spielphase
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zur√ºcksetzen f√ºr 6-Kipp-Regel
      kippCount = 0;
      autoEvalTimeout = null;
      
      // Tap-Counter zur√ºcksetzen
      tapCount = 0;
      updateTapIndicators();
      
      // Liegezeit-Tracking (erste Liegezeit = Denkzeit, kein Auto-Eval)
      liegeZeiten = [];
      liegeStartTime = performance.now();

      // K√§rtchen werden in fillAllCards() sichtbar gemacht - NICHT hier

      // K√§rtchen bef√ºllen: Nur das erste (Index 0) initial generieren
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      
      // Alle Card-Flags zur√ºcksetzen
      gameCards.forEach(c => {
        c.zahl = null;
        c.color = null;
        c.isHit = false;
        c.isMiss = false;
      });
      
      // Warten bis Texturen geladen sind, dann K√§rtchen bef√ºllen
      function fillAllCards() {
        if (!texturesReady || !leerImage) {
          setTimeout(fillAllCards, 50);
          return;
        }
        
        // Erstes K√§rtchen mit bereits generiertem Kippziel bef√ºllen
        if (erstesKippziel) {
          fillCardWithKombi(0, erstesKippziel.zahl, erstesKippziel.color);
        } else {
          // Fallback falls kein Kippziel vorgemerkt
          const erfuellteKombis = getCurrentErfuellteKombis();
          const visibleZahlen = getCurrentVisibleZahlen();
          const zahlenFilter = openKippzielPositions.has(0) && offeneKippzieleVergeben < 2 ? 'open' : 'closed';
          let neueKombi = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
          if (!neueKombi) neueKombi = generateNeueKombiOhne(erfuellteKombis);
          if (neueKombi) {
            if (visibleZahlen.has(neueKombi.zahl)) offeneKippzieleVergeben++;
            fillCardWithKombi(0, neueKombi.zahl, neueKombi.color);
          }
        }
        
        // Restliche 5 K√§rtchen (i=1 bis i=5) UNSICHTBAR machen
        for (let i = 1; i < 6; i++) {
          gameCards[i].mesh.visible = false;
        }
      }
      fillAllCards();
      
      setButtonsDisabled(false);
    }
    
    // === Spielen-Phase f√ºr Runde 2+ (ohne Reset) ===
    function startSpielenForCurrentRound() {
      gamePhase = 'spielen';
      currentMode = 'kanten';
      kippzielChecked = false;
      
      // Countdown STOPPEN
      stopCountdown();
      
      // UI umschalten
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      
      // verdecktesMesh bleibt sichtbar (zeigt aufgedecktes Kippziel)
      verdecktesMesh.userData.revealed = true;
      
      // Buttons versteckt
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      
      // Richtungs-Lock zur√ºcksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // Zielscheibe positionieren und anzeigen
      updateKippTargetPosition();
      document.getElementById('kippTarget').style.display = 'block';
      
      // Timer aus
      stopCountdown();
      countdown.style.display = 'none';
      
      // kippCount zur√ºcksetzen
      kippCount = 0;
      autoEvalTimeout = null;
      
      // Tap-Counter zur√ºcksetzen
      tapCount = 0;
      updateTapIndicators();
      
      // Liegezeit-Tracking
      liegeZeiten = [];
      liegeStartTime = performance.now();
      
      // Aktuelles K√§rtchen mit dem generierten Kippziel bef√ºllen
      if (erstesKippziel) {
        fillCardWithKombi(activeCardIdx, erstesKippziel.zahl, erstesKippziel.color);
      }
      
      setButtonsDisabled(false);
    }

    actionButton.addEventListener('click', () => {
      if (gamePhase === 'spielziel') {
        initEntscheidungPhase();
      } else if (gamePhase === 'kippen') {
        phaseKippenToSpielen();
      } else if (gamePhase === 'pause') {
        endPausePhase();
      } else if (gamePhase === 'ende') {
        // "Neues Spiel" ‚Üí Reset + direkt ins Spiel (ohne Erkl√§rung)
        document.getElementById('brainScore').style.display = 'none';
        document.getElementById('brainScore').style.opacity = '0';
        isReplay = true;
        resetButton.click();
      }
    });
    
    // === Aufdecken des verdeckten Kippziels ===
    function revealVerdecktesKippziel() {
      if (!texturesReady) return;
      
      // SCHAUEN-Timer stoppen
      stopCountdown();
      countdown.style.display = 'none';
      
      // Demo-Animation stoppen falls noch aktiv
      isDemoAnimating = false;
      handDemo.visible = false;
      
      // Kippziel generieren mit open/closed Filter
      const erfuellteKombis = getCurrentErfuellteKombis();
      const visibleZahlen = getCurrentVisibleZahlen();
      
      let zahlenFilter = undefined;
      if (openKippzielPositions.has(activeCardIdx) && offeneKippzieleVergeben < 2) {
        zahlenFilter = 'open';
      } else {
        zahlenFilter = 'closed';
      }
      
      erstesKippziel = generateNeueKombiOhne(erfuellteKombis, zahlenFilter, visibleZahlen);
      
      // Fallback: wenn Filter nichts liefert, ohne Filter versuchen
      if (!erstesKippziel) {
        erstesKippziel = generateNeueKombiOhne(erfuellteKombis);
      }
      if (!erstesKippziel) return;
      
      // Tracking: war es eine sichtbare Zahl?
      if (visibleZahlen.has(erstesKippziel.zahl)) {
        offeneKippzieleVergeben++;
      }
      
      // Farb-Image + Zahl auf verdecktes Canvas zeichnen
      const img = colorTargetImages[erstesKippziel.color.name];
      if (!img) return;
      
      verdecktesCtx.clearRect(0, 0, 85, 170);
      verdecktesCtx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
      verdecktesCtx.fillStyle = '#2a1810';
      verdecktesCtx.font = 'bold 56px Arial';
      verdecktesCtx.textAlign = 'center';
      verdecktesCtx.textBaseline = 'middle';
      verdecktesCtx.fillText(displayText, 42, 42);
      verdecktesCanvasTex.needsUpdate = true;
      
      // Puls stoppen, volle Deckkraft
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      verdecktesMesh.userData.revealed = true;
      
      // instructionText ausblenden
      document.getElementById('instructionText').style.display = 'none';
      // Entscheidungs-UI ausblenden
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      
      // Nach 1,5s Spielphase starten
      setTimeout(() => {
        if (activeCardIdx === 0) {
          phaseKippenToSpielen(); // Erste Runde: volles Init
        } else {
          startSpielenForCurrentRound(); // Folgerunden: ohne Reset
        }
      }, 1500);
    }
    
    // Tap-auf-W√ºrfel Flag
    let kippzielChecked = false;
    
    // verdecktes Kippziel Tap-Erkennung (Raycaster)
    const vkRaycaster = new THREE.Raycaster();
    const vkMouse = new THREE.Vector2();
    let lastTouchPos = null;
    
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (((gamePhase === 'kippen' || gamePhase === 'entscheidung') && verdecktesMesh.visible && !verdecktesMesh.userData.revealed) ||
          (gamePhase === 'spielen' && !kippzielChecked)) {
        lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }, { passive: true });
    
    renderer.domElement.addEventListener('touchend', (e) => {
      if ((gamePhase !== 'kippen' && gamePhase !== 'entscheidung') || !verdecktesMesh.visible || !lastTouchPos || verdecktesMesh.userData.revealed) return;
      if (dragActive) { lastTouchPos = null; return; }
      
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((lastTouchPos.x - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((lastTouchPos.y - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        revealVerdecktesKippziel();
      }
      lastTouchPos = null;
    }, { passive: true });
    
    // Desktop-Klick: Kippziel aufdecken (kippen) ODER W√ºrfel-Tap (spielen)
    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      vkMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      vkMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      vkRaycaster.setFromCamera(vkMouse, camera);
      
      // Spielen: Tap auf W√ºrfel
      if (gamePhase === 'spielen' && !kippzielChecked && !isAnimating) {
        if (vkRaycaster.intersectObject(cube).length > 0 && tapCount < 6) {
          tapCount++;
          updateTapIndicators();
          
        }
        return;
      }
      
      if ((gamePhase !== 'kippen' && gamePhase !== 'entscheidung') || !verdecktesMesh.visible || verdecktesMesh.userData.revealed) return;
      if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
        revealVerdecktesKippziel();
      }
    });
    
    // (Spielen: Tap auf W√ºrfel z√§hlt Kipps, Swipe startet Auto-Kipp-Sequenz)
    
    // Kippziel-Check bei Tap auf W√ºrfel
    function checkKippzielTap() {
      if (!erstesKippziel || kippzielChecked) return;
      kippzielChecked = true;
      
      // Auto-Eval Timeout sicherheitshalber l√∂schen
      if (autoEvalTimeout) {
        clearTimeout(autoEvalTimeout);
        autoEvalTimeout = null;
      }
      
      // Timer stoppen
      stopCountdown();
      
      // 6-Kipp-Regel: mehr als 6 = auto-miss
      if (kippCount > 6) {
        console.log('=== AUTO-MISS: mehr als 6 Kipps ===');
        drawKippzielBorder(false);
        return;
      }
      
      // Treffer pr√ºfen
      const faceOff = { f0: 0, f1: 4, f2: 8 };
      const off = faceOff[topFace];
      const visible = { S1: deck[off], S2: deck[off+1], S3: deck[off+2], S4: deck[off+3] };
      
      let hitSlot = null;
      for (const [slot, val] of Object.entries(visible)) {
        if (val === erstesKippziel.zahl) { hitSlot = slot; break; }
      }
      
      let isHit = false;
      if (hitSlot) {
        const neighborColor = SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot];
        isHit = (neighborColor === erstesKippziel.color.name);
      }
      
      console.log('=== KIPPZIEL AUTO-EVAL ===');
      console.log('Ziel:', erstesKippziel.zahl, erstesKippziel.color.name);
      console.log('topFace:', topFace, 'Q:', currentQuadrant, 'kippCount:', kippCount);
      console.log('Sichtbare Slots:', JSON.stringify(visible));
      console.log('hitSlot:', hitSlot);
      if (hitSlot) console.log('Farbe an Slot:', SLOT_NEIGHBOR_COLORS[currentQuadrant][hitSlot]);
      console.log('Ergebnis:', isHit ? 'TREFFER' : 'MISS');
      
      drawKippzielBorder(isHit);
    }
    
    function drawKippzielBorder(isHit) {
      if (isHit) {
        // Treffer: goldgelber Rahmen mit Outer Glow
        // Glow-Effekt (mehrere halbtransparente Rahmen au√üen‚Üíinnen)
        verdecktesCtx.shadowColor = '#FFD700';
        verdecktesCtx.shadowBlur = 12;
        verdecktesCtx.strokeStyle = '#FFD700';
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        verdecktesCtx.shadowBlur = 0;
        
        // Innerer heller Rahmen
        verdecktesCtx.strokeStyle = '#FFF0A0';
        verdecktesCtx.lineWidth = 1;
        verdecktesCtx.strokeRect(7, 7, 71, 156);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Puls-Animation: kurz gr√∂√üer, dann zur√ºck
        const origScale = 1;
        const pulseScale = 1.25;
        const pulseDur = 300;
        const startTime = performance.now();
        function pulseTick(now) {
          const t = Math.min((now - startTime) / pulseDur, 1);
          const s = t < 0.5
            ? origScale + (pulseScale - origScale) * (t * 2)
            : pulseScale - (pulseScale - origScale) * ((t - 0.5) * 2);
          verdecktesMesh.scale.set(s, s, s);
          if (t < 1) requestAnimationFrame(pulseTick);
          else verdecktesMesh.scale.set(origScale, origScale, origScale);
        }
        requestAnimationFrame(pulseTick);
        
        // Nach 2s zur n√§chsten Runde
        setTimeout(() => proceedToNextRound(true), 2000);
        
      } else {
        // Miss: Zahl grau zeichnen
        const img = colorTargetImages[erstesKippziel.color.name];
        if (img) {
          verdecktesCtx.clearRect(0, 0, 85, 170);
          verdecktesCtx.drawImage(img, 0, 0, 85, 170);
          
          // Farbs√§ttigung reduzieren
          verdecktesCtx.globalCompositeOperation = 'saturation';
          verdecktesCtx.fillStyle = 'hsl(0, 40%, 50%)';
          verdecktesCtx.fillRect(0, 0, 85, 170);
          verdecktesCtx.globalCompositeOperation = 'source-over';
          
          // Zahl in Grau
          const displayText = erstesKippziel.zahl + ((erstesKippziel.zahl === 6 || erstesKippziel.zahl === 9) ? '.' : '');
          verdecktesCtx.fillStyle = '#888888';
          verdecktesCtx.font = 'bold 56px Arial';
          verdecktesCtx.textAlign = 'center';
          verdecktesCtx.textBaseline = 'middle';
          verdecktesCtx.fillText(displayText, 42, 42);
        }
        
        // Roter Rahmen
        verdecktesCtx.strokeStyle = '#FF2020';
        verdecktesCtx.lineWidth = 2;
        verdecktesCtx.strokeRect(1, 1, 83, 168);
        verdecktesCtx.lineWidth = 4;
        verdecktesCtx.strokeRect(4, 4, 77, 162);
        
        verdecktesCanvasTex.needsUpdate = true;
        
        // Nach 2s zur n√§chsten Runde
        setTimeout(() => proceedToNextRound(false), 2000);
      }
    }

    function proceedToNextRound(isHit) {
      // 1. Visuellen Zustand von verdecktesMesh auf gameCard √ºbertragen
      const card = gameCards[activeCardIdx];
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(verdecktesCanvas, 0, 0);
      card.texture.needsUpdate = true;
      card.mesh.material.map = card.texture;
      card.mesh.material.transparent = false;
      card.mesh.material.opacity = 1;
      card.mesh.material.needsUpdate = true;
      card.mesh.visible = true;
      
      // 2. Treffer tracken
      if (isHit && erstesKippziel) {
        bereitsGetroffen.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 3. Kombi als ausgegeben markieren
      if (erstesKippziel) {
        bereitsAusgegeben.add(erstesKippziel.zahl + '_' + erstesKippziel.color.name);
      }
      
      // 4. Weiter
      activeCardIdx++;
      
      // 5. Spielende?
      if (activeCardIdx >= 6) {
        verdecktesMesh.visible = false;
        document.getElementById('kippTarget').style.display = 'none';
        showGameEnd();
        return;
      }
      
      // 6. N√§chste Entscheidungs-Runde
      initNextRoundEntscheidung();
    }

    function initNextRoundEntscheidung() {
      gamePhase = 'entscheidung';
      kippzielChecked = false;
      erstesKippziel = null;
      
      // ALLE Texte ausblenden - nach erstem Kippziel keine Texte mehr
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('kippTarget').style.display = 'none';
      tapCount = 0;
      tapIndicatorA.mesh.visible = false;
      tapIndicatorB.mesh.visible = false;
      
      // Richtungs-Lock zur√ºcksetzen
      lockedKippDir = null;
      currentDragDir = null;
      
      // verdecktesMesh an n√§chste K√§rtchen-Position verschieben
      const nextX = cardStartX + activeCardIdx * (cardWidth + cardGap);
      verdecktesMesh.position.set(nextX, cardY + 0.001, cardZ);
      verdecktesMesh.userData.revealed = false;
      drawLeernohitOnVerdecktes();
      verdecktesMesh.visible = true;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      
      // Auge an fester Position einblenden (zentriert, pulsierend)
      const eyeIcon = document.getElementById('eyeIcon');
      eyeIcon.style.display = 'block';
      
      // Timer ausblenden
      countdown.style.display = 'none';
    }

    function startFreeSchauenPhase() {
      gamePhase = 'kippen';
      
      // Auge ausblenden, keine Texte
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      
      // Timer "0" anzeigen und starten (60 Sek max)
      countdown.textContent = '0';
      countdown.style.display = 'block';
      if (timerTopPos) countdown.style.top = timerTopPos;
      countdown.style.left = '180px';
      
      startCountdown(() => {
        if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
          revealVerdecktesKippziel();
        }
      }, 60);
      
      // W√ºrfel bleibt wo er ist - KEIN Reset!
    }

    backButton.addEventListener('click', () => {
      if (gamePhase !== 'kippen' && gamePhase !== 'spielen') return;
      gamePhase = 'kippen'; // Zur√ºck zu Phase 2
      currentMode = 'kanten';
      kippCount = 0;
      if (autoEvalTimeout) { clearTimeout(autoEvalTimeout); autoEvalTimeout = null; }
      
      // UI zur√ºcksetzen zu Phase 2
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      stopCountdown();
      countdown.style.display = 'none';
      if (activeCardIdx === 0 && !isReplay) {
        document.getElementById('instructionText').style.display = 'block';
      }
      document.getElementById('tutorialText').style.display = 'none';
      
      // SCHAUEN-Timer neu starten
      startCountdown(() => {
        if ((gamePhase === 'demo' || gamePhase === 'kippen') && !verdecktesMesh.userData.revealed) {
          gamePhase = 'kippen';
          revealVerdecktesKippziel();
        }
      }, 60);
      verdecktesMesh.visible = true;
      verdecktesMesh.userData.revealed = false;
      verdecktesMesh.scale.set(1, 1, 1);
      verdecktesMat.opacity = 1;
      erstesKippziel = null;
      kippzielChecked = false;
      lockedKippDir = null;
      currentDragDir = null;
      tapCount = 0;
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      drawLeernohitOnVerdecktes();
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      
      // K√§rtchen verstecken
      gameCards.forEach(c => c.mesh.visible = false);
      
      // W√ºrfel zur√ºcksetzen zu Q3
      cube.position.set(-offset, offset, 0.109375 + offset);
      cube.rotation.set(0, 0, 0);
      currentQuadrant = 3;
      topFace = 'f2'; // Anfangslage zur√ºcksetzen
      
    });
    
    // Reset-Button: Zur√ºck zu SPIEL ZIEL
    resetButton.addEventListener('click', () => {
      stopCountdown();
      if (autoEvalTimeout) { clearTimeout(autoEvalTimeout); autoEvalTimeout = null; }
      countdown.style.display = 'none';
      isDemoAnimating = false;
      handDemo.visible = false;
      
      document.getElementById('instructionText').style.display = 'none';
      document.getElementById('tutorialText').style.display = 'none';
      document.getElementById('eyeIcon').style.display = 'none';
      document.getElementById('entscheidungText').style.display = 'none';
      hintText.style.display = 'none';
      actionButton.style.display = 'none';
      kippButtons.classList.add('hidden');
      document.getElementById('richtungButtons').classList.add('hidden');
      resetButton.style.display = 'none';
      
      gameCards.forEach(c => c.mesh.visible = false);
      
      cube.quaternion.set(0, 0, 0, 1);
      cube.position.set(-offset, offset, 0.109375 + offset);
      currentQuadrant = 3;
      topFace = 'f2';
      kippCount = 0;
      lockedKippDir = null;
      currentDragDir = null;
      erstesKippziel = null;
      kippzielChecked = false;
      totalObservationTime = 0;
      tapCount = 0;
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      activeCardIdx = 0;
      bereitsGetroffen.clear();
      bereitsAusgegeben.clear();
      offeneKippzieleVergeben = 0;
      openKippzielPositions = pickTwoRandomPositions();
      
      gamePhase = 'spielziel';
      initSpielzielPhase();
    });

    // =========================
    // W√úRFEL-KIPPMECHANIK
    // =========================
    // DRAG-KIPP-STEUERUNG (Phase 2)
    // =========================
    let isSwiping = false;
    let swipeStartX = 0;
    let swipeStartY = 0;
    let isAnimating = false;
    let currentQuadrant = 3;

    // Drag-State
    let dragActive = false;
    let dragPivotGroup = null;
    let dragAxis = null;
    let dragTargetSign = 0;
    let dragToQ = 0;
    let dragCurrentAngle = 0;
    const DRAG_SENSITIVITY = 150; // px f√ºr volle 90¬∞

    // =========================
    // PAUSE-PHASE: Ecke-Drehinteraktion
    // =========================
    // 8 Ecken des W√ºrfels nach body-diagonal-Rotation (Pivot = Ecke, vorberechnet)
    const ECKE_CORNERS = [
      [ 0.000000,  0.000000,  0.000000],
      [ 0.369691,  0.270633, -0.099059],
      [-0.270633,  0.270633, -0.270633],
      [-0.099059,  0.270633,  0.369691],
      [ 0.099059,  0.541266, -0.369691],
      [ 0.270633,  0.541266,  0.270633],
      [-0.369691,  0.541266,  0.099059],
      [ 0.000000,  0.811899,  0.000000]
    ];
    // Frame-Grenzen relativ zum Pivot (0, 0, 0.109375)
    const PAUSE_LIMIT_S =  0.4705;   // s√ºd  (wallInnerSouth - pivotZ)
    const PAUSE_LIMIT_N =  0.46875;  // nord
    const PAUSE_LIMIT_E =  0.46875;  // ost
    const PAUSE_LIMIT_W =  0.46875;  // west

    function isPausePoseValid(alpha, beta) {
      const ca = Math.cos(alpha), sa = Math.sin(alpha);
      const cb = Math.cos(beta),  sb = Math.sin(beta);
      for (const [x, y, z] of ECKE_CORNERS) {
        // Ry(Œ≤) zuerst
        const x1 =  x * cb + z * sb;
        const z1 = -x * sb + z * cb;
        // Rx(Œ±) danach
        const z2 = y * sa + z1 * ca;
        // x √§ndert sich durch Rx nicht ‚Üí x1 bleiben
        if ( x1 > PAUSE_LIMIT_E || -x1 > PAUSE_LIMIT_W) return false;
        if ( z2 > PAUSE_LIMIT_S || -z2 > PAUSE_LIMIT_N) return false;
      }
      return true;
    }

    function getMaxBeta(alpha, sign) {
      // sign: +1 oder -1
      if (!isPausePoseValid(alpha, 0)) return 0;
      let lo = 0, hi = Math.PI;
      for (let i = 0; i < 16; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(alpha, sign * mid)) lo = mid; else hi = mid;
      }
      return lo;
    }

    function getMaxAlpha(beta) {
      if (!isPausePoseValid(0, beta)) return 0;
      let lo = 0, hi = Math.PI / 6; // 30¬∞ als obere Suche
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        if (isPausePoseValid(mid, beta)) lo = mid; else hi = mid;
      }
      return lo;
    }

    let pausePivotGroup = null;
    let aufEckeTargetQuat = null;
    let pauseSpringRunning = false;
    let pauseTimerRef = null;
    let pauseExiting = false;
    let savedCubePosition = null;  // Position vor animateAufEcke
    let savedCubeQuaternion = null; // Quaternion vor animateAufEcke
    let savedTopFace = null;  // topFace vor animateAufEcke
    let savedCurrentQuadrant = null; // currentQuadrant vor animateAufEcke
    let pauseAlpha = 0;
    let pauseBeta  = 0;
    let pauseDragActive = false;
    let pauseDragStartX = 0;
    let pauseDragStartY = 0;
    let pauseDragStartAlpha = 0;
    let pauseDragStartBeta  = 0;
    const PAUSE_SENSITIVITY = 200; // px f√ºr ~30¬∞
    let totalObservationTime = 0; // Sekunden f√ºr Brain Score Berechnung

    function getKippConfig(direction) {
      const configs = {
        'north':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation: -Math.PI/2, toQ: 0 },
        'south':         { pivotPoint: new THREE.Vector3(-0.234375, 0, 0.109375), axis: 'x', targetRotation:  Math.PI/2, toQ: 3 },
        'east':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 1 },
        'west':          { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 0 },
        'south_from_q1': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation:  Math.PI/2, toQ: 2 },
        'north_from_q2': { pivotPoint: new THREE.Vector3(0.234375, 0, 0.109375),  axis: 'x', targetRotation: -Math.PI/2, toQ: 1 },
        'west_from_q2':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation:  Math.PI/2, toQ: 3 },
        'east_from_q3':  { pivotPoint: new THREE.Vector3(0, 0, 0.343125),         axis: 'z', targetRotation: -Math.PI/2, toQ: 2 }
      };
      return configs[direction];
    }

    function getValidDirection(deltaX, deltaY) {
      if (Math.abs(deltaY) >= Math.abs(deltaX)) {
        if (deltaY < 0) {
          if (currentQuadrant === 3) return 'north';
          if (currentQuadrant === 2) return 'north_from_q2';
        } else {
          if (currentQuadrant === 0) return 'south';
          if (currentQuadrant === 1) return 'south_from_q1';
        }
      } else {
        if (deltaX > 0) {
          if (currentQuadrant === 0) return 'east';
          if (currentQuadrant === 3) return 'east_from_q3';
        } else {
          if (currentQuadrant === 1) return 'west';
          if (currentQuadrant === 2) return 'west_from_q2';
        }
      }
      return null;
    }


    renderer.domElement.addEventListener('touchstart', (e) => {
      // Demo-Phase beenden beim ersten Touch
      if (gamePhase === 'demo') {
        e.preventDefault(); // Touch w√§hrend Demo verarbeiten
        
        gamePhase = 'kippen';
        isDemoAnimating = false; // Animation sofort stoppen
        handDemo.visible = false; // Hand sofort ausblenden
        
        // SCHAUEN-Timer jetzt starten (60 Sek)
        startCountdown(() => {
          if (gamePhase === 'kippen' && !verdecktesMesh.userData.revealed) {
            revealVerdecktesKippziel();
          }
        }, 60);
        
        // ALLE State-Variablen sauber resetten
        cube.quaternion.set(0, 0, 0, 1); // Reset zu neutraler Rotation
        cube.position.set(-offset, offset, 0.109375 + offset);
        currentQuadrant = 3;
        topFace = 'f2';
        dragActive = false;
        isAnimating = false;
        
        // Touch-Punkt SOFORT f√ºr Drag-System speichern
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        
        // Auch f√ºr Raycaster (verdecktes Kippziel) speichern
        if (verdecktesMesh.visible) {
          lastTouchPos = { x: touch.clientX, y: touch.clientY };
        }
        
        return; // Demo-Stop komplett, jetzt touchmove √ºbernimmt
      }
      
      if (gamePhase === 'pause' && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        pauseDragStartX = touch.clientX;
        pauseDragStartY = touch.clientY;
        pauseDragStartAlpha = pauseAlpha;
        pauseDragStartBeta  = pauseBeta;
        pauseDragActive = true;
        return;
      }
      if (currentMode === 'kanten' && (gamePhase === 'kippen' || gamePhase === 'spielen')) {
        if (isAnimating) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        swipeStartX = touch.clientX;
        swipeStartY = touch.clientY;
        isSwiping = true;
        dragActive = false;
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (gamePhase === 'pause' && pauseDragActive && pausePivotGroup) {
        e.preventDefault();
        const touch = e.touches[0];
        const dx = touch.clientX - pauseDragStartX;
        const dy = touch.clientY - pauseDragStartY;

        // Œ≤: X-Drag ‚Üí Y-Rotation (links = positiv)
        let newBeta  = pauseDragStartBeta  + (dx / PAUSE_SENSITIVITY) * Math.PI;
        // Œ±: Y-Drag nach unten ‚Üí Tilt nach S√ºden
        let newAlpha = pauseDragStartAlpha + (dy / PAUSE_SENSITIVITY) * (Math.PI / 3);
        newAlpha = Math.max(0, newAlpha);

        // Alpha clampen bei gegebenem Beta
        const maxA = getMaxAlpha(newBeta);
        newAlpha = Math.min(newAlpha, maxA);

        // Beta clampen bei gegebenem Alpha
        if (!isPausePoseValid(newAlpha, newBeta)) {
          const sign = newBeta >= 0 ? 1 : -1;
          const maxB = getMaxBeta(newAlpha, sign);
          newBeta = sign * maxB;
        }

        pauseAlpha = newAlpha;
        pauseBeta  = newBeta;

        // Euler 'YXZ': erst Ry(Œ≤), dann Rx(Œ±)
        pausePivotGroup.rotation.set(pauseAlpha, pauseBeta, 0, 'YXZ');
        return;
      }
      if (!isSwiping || isAnimating || (gamePhase !== 'kippen' && gamePhase !== 'spielen') || currentMode !== 'kanten') return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - swipeStartX;
      const deltaY = touch.clientY - swipeStartY;

      // Warte auf minimale Bewegung bevor Richtung bestimmt wird
      if (!dragActive) {
        if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < 8) return;

        const direction = getValidDirection(deltaX, deltaY);
        if (!direction) { isSwiping = false; return; }
        
        // SPIELEN-Phase: Swipe bestimmt Richtung ‚Üí Auto-Kipp-Sequenz
        if (gamePhase === 'spielen') {
          isSwiping = false;
          if (tapCount <= 0 || kippzielChecked || isAnimating) return;
          
          const isCW = CW_DIRS.has(direction);
          lockedKippDir = isCW ? 'cw' : 'ccw';
          kippDirection = lockedKippDir;
          
          // Tutorial-Text ausblenden
          document.getElementById('tutorialText').style.display = 'none';
          
          // Auto-Kipp starten
          runAutoKippSequence(tapCount);
          return;
        }
        
        // SCHAUEN-Phase: normaler manueller Drag
        currentDragDir = direction;

        const config = getKippConfig(direction);
        dragAxis = config.axis;
        dragTargetSign = config.targetRotation > 0 ? 1 : -1;
        dragToQ = config.toQ;

        // Pivot-Gruppe setup
        dragPivotGroup = new THREE.Group();
        dragPivotGroup.position.copy(config.pivotPoint);
        kipGroup.add(dragPivotGroup);

        cube.updateMatrixWorld();
        const cubeWorldPos = new THREE.Vector3();
        cube.getWorldPosition(cubeWorldPos);
        kipGroup.remove(cube);
        cube.position.copy(cubeWorldPos.clone().sub(config.pivotPoint));
        dragPivotGroup.add(cube);

        dragActive = true;
        dragCurrentAngle = 0;
      }

      // Rotation live berechnen
      // X-Achse: deltaY direkt (oben neg, unten pos)
      // Z-Achse: -deltaX (rechts pos wird neg Rotation)
      const relevantDelta = (dragAxis === 'x') ? deltaY : -deltaX;
      let angle = (relevantDelta / DRAG_SENSITIVITY) * (Math.PI / 2);

      // Clamp zwischen 0 und targetRotation
      if (dragTargetSign > 0) {
        angle = Math.max(0, Math.min(Math.PI / 2, angle));
      } else {
        angle = Math.min(0, Math.max(-Math.PI / 2, angle));
      }

      dragCurrentAngle = angle;

      if (dragAxis === 'x') {
        dragPivotGroup.rotation.x = dragCurrentAngle;
      } else {
        dragPivotGroup.rotation.z = dragCurrentAngle;
      }
    });

    function finishPauseToSpiel() {
      // PivotGroup aufl√∂sen
      if (pausePivotGroup) {
        pausePivotGroup.remove(cube);
        kipGroup.remove(pausePivotGroup);
        pausePivotGroup = null;
        kipGroup.add(cube);
      }

      // Gespeicherter Zustand vor der Pause ‚Äî immer wiederherstellen
      cube.position.copy(savedCubePosition);
      cube.quaternion.copy(savedCubeQuaternion);
      topFace = savedTopFace;
      currentQuadrant = savedCurrentQuadrant;

      gamePhase = 'spielen';
      // Buttons bleiben versteckt (Tutorial-Modus: Swipe-Kipping)
      document.getElementById('richtungButtons').classList.add('hidden');
      kippButtons.classList.add('hidden');
      updateKippTargetPosition();
      document.getElementById('kippTarget').style.display = 'block';

      // Pause-Lichter aus
      pauseLights.forEach(l => l.visible = false);
      
      // Nur die bereits gespielten K√§rtchen sichtbar machen und opacity wiederherstellen
      gameCards.forEach((c, i) => {
        if (c.zahl || c.isHit || c.isMiss) {
          c.mesh.visible = true;
          if (i < savedCardOpacities.length) {
            c.mesh.material.opacity = savedCardOpacities[i];
            c.mesh.material.transparent = (savedCardOpacities[i] < 1);
            c.mesh.material.needsUpdate = true;
          }
        }
      });
      
      setButtonsDisabled(false);
    }

    renderer.domElement.addEventListener('touchend', () => {
      if (gamePhase === 'pause') {
        pauseDragActive = false;
        return;
      }
      isSwiping = false;
      
      // SPIELEN-Phase: Tap auf W√ºrfel = tapCount erh√∂hen
      if (gamePhase === 'spielen' && !dragActive && !kippzielChecked && !isAnimating && lastTouchPos) {
        const rect = renderer.domElement.getBoundingClientRect();
        vkMouse.x = ((lastTouchPos.x - rect.left) / rect.width) * 2 - 1;
        vkMouse.y = -((lastTouchPos.y - rect.top) / rect.height) * 2 + 1;
        vkRaycaster.setFromCamera(vkMouse, camera);
        if (vkRaycaster.intersectObject(cube).length > 0) {
          if (tapCount < 6) {
            tapCount++;
            updateTapIndicators();
            
          }
        }
        lastTouchPos = null;
        return;
      }
      
      if (!dragActive) return;

      // Tipping-Point bei 45¬∞ (PI/4)
      const absAngle = Math.abs(dragCurrentAngle);
      let targetAngle, finalQ;

      if (absAngle > Math.PI / 4) {
        targetAngle = dragTargetSign * Math.PI / 2; // Kippen
        finalQ = dragToQ;
      } else {
        targetAngle = 0; // Zur√ºckfallen
        finalQ = currentQuadrant;
      }

      // Schwerkraft-Fall-Animation
      isAnimating = true;
      const startAngle = dragCurrentAngle;
      const angleDiff = targetAngle - startAngle;
      const fallDuration = Math.max(150, Math.abs(angleDiff) / (Math.PI / 2) * 420);
      const startTime = Date.now();

      function animateFall() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fallDuration, 1);

        // Ease-in (t¬≤) = Schwerkraft-Beschleunigung
        const eased = progress * progress;
        const currentAngle = startAngle + angleDiff * eased;

        if (dragAxis === 'x') {
          dragPivotGroup.rotation.x = currentAngle;
        } else {
          dragPivotGroup.rotation.z = currentAngle;
        }

        if (progress < 1) {
          requestAnimationFrame(animateFall);
        } else {
          if (targetAngle === 0) {
            // Zur√ºckgefallen: W√ºrfel zur√ºck in kipGroup
            cube.updateMatrixWorld();
            const newPos = new THREE.Vector3();
            cube.getWorldPosition(newPos);
            const newQuat = new THREE.Quaternion();
            cube.getWorldQuaternion(newQuat);
            dragPivotGroup.remove(cube);
            kipGroup.remove(dragPivotGroup);
            cube.position.copy(newPos);
            cube.quaternion.copy(newQuat);
            kipGroup.add(cube);
          } else {
            // Gekippt: finalisieren
            finalizeKipp(finalQ, null);
            
            // topFace bei jedem Kipp aktualisieren (kippen + spielen)
            if ((gamePhase === 'kippen' || gamePhase === 'spielen') && currentDragDir) {
              const isCW = CW_DIRS.has(currentDragDir);
              kippDirection = isCW ? 'cw' : 'ccw';
              advanceTopFace();
            }
          }
          dragActive = false;
          dragPivotGroup = null;
          isAnimating = false;
        }
      }

      animateFall();
    });

    // Desktop-Support: Click startet Spielphase
    renderer.domElement.addEventListener('click', (e) => {
      if (gamePhase === 'demo') {
        gamePhase = 'kippen';
        handDemo.visible = false;
        
        // Direkt pr√ºfen ob verdecktes Kippziel angeklickt wurde
        if (verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
          const rect = renderer.domElement.getBoundingClientRect();
          vkMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          vkMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          vkRaycaster.setFromCamera(vkMouse, camera);
          if (vkRaycaster.intersectObject(verdecktesMesh).length > 0) {
            revealVerdecktesKippziel();
          }
        }
        return;
      }
    });
    
    async function performKipp(direction, duration = 800) {
      if (isAnimating) return;
      isAnimating = true;
      
      let pivotPoint, axis, targetRotation, fromQ, toQ;
      
      if (direction === 'north') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 0;
      } else if (direction === 'south') {
        pivotPoint = new THREE.Vector3(-0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 0;
        toQ = 3;
      } else if (direction === 'east') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 0;
        toQ = 1;
      } else if (direction === 'west') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 0;
      } else if (direction === 'south_from_q1') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = Math.PI / 2;
        fromQ = 1;
        toQ = 2;
      } else if (direction === 'north_from_q2') {
        pivotPoint = new THREE.Vector3(0.234375, 0, 0.109375);
        axis = 'x';
        targetRotation = -Math.PI / 2;
        fromQ = 2;
        toQ = 1;
      } else if (direction === 'west_from_q2') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = Math.PI / 2;
        fromQ = 2;
        toQ = 3;
      } else if (direction === 'east_from_q3') {
        pivotPoint = new THREE.Vector3(0, 0, 0.109375 + 0.234375);
        axis = 'z';
        targetRotation = -Math.PI / 2;
        fromQ = 3;
        toQ = 2;
      }
      
      const pivotGroup = new THREE.Group();
      pivotGroup.position.copy(pivotPoint);
      kipGroup.add(pivotGroup);
      
      cube.updateMatrixWorld();
      const cubeWorldPos = new THREE.Vector3();
      cube.getWorldPosition(cubeWorldPos);
      
      kipGroup.remove(cube);
      
      const relativePos = cubeWorldPos.clone().sub(pivotPoint);
      cube.position.copy(relativePos);
      pivotGroup.add(cube);
      
      const startTime = Date.now();
      
      return new Promise((resolve) => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          if (axis === 'x') {
            pivotGroup.rotation.x = eased * targetRotation;
          } else {
            pivotGroup.rotation.z = eased * targetRotation;
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            finalizeKipp(toQ, resolve);
          }
        }
        
        animate();
      });
    }
    
    function finalizeKipp(newQ, callback) {
      cube.updateMatrixWorld();
      const newWorldPos = new THREE.Vector3();
      cube.getWorldPosition(newWorldPos);
      const newWorldQuat = new THREE.Quaternion();
      cube.getWorldQuaternion(newWorldQuat);
      
      const parent = cube.parent;
      if (parent && parent.parent) {
        parent.parent.remove(parent);
      }
      
      cube.position.copy(newWorldPos);
      cube.quaternion.copy(newWorldQuat);
      kipGroup.add(cube);
      
      currentQuadrant = newQ;
      isAnimating = false;
      if (callback) callback();
    }

    // =========================
    // KIPP-SEQUENZ mit 2D-Timing
    // =========================
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runKippSequence(steps) {
      if (isAnimating) return;
      
      const T = getTiming();
      const kipFactor = 1;
      
      
      for (let i = 0; i < steps; i++) {
        const tStep = (steps <= 1) ? 0 : (i / (steps - 1));
        const stepMul = lerp(1.0, STEP_MAX, tStep);
        
        const kipTime = Math.max(40, Math.round(T.kipMs * kipFactor * stepMul));
        const holdTime = Math.max(40, Math.round(T.wMs * stepMul));
        
        
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north'; // Q3
        } else {
          // CCW: umgekehrte Reihenfolge
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3'; // Q3
        }
        
        await performKipp(direction, kipTime);
        advanceTopFace();
        await sleep(holdTime);
      }
    }

    // === Auto-Kipp-Sequenz f√ºr Spielphase ===
    async function runAutoKippSequence(steps) {
      if (isAnimating || kippzielChecked) return;
      isAnimating = true;
      
      // Tap-Counter und Zielkreis ausblenden
      tapIndicatorA.mesh.visible = false; tapIndicatorB.mesh.visible = false;
      document.getElementById('kippTarget').style.display = 'none';
      
      for (let i = 0; i < steps; i++) {
        let direction;
        if (kippDirection === 'cw') {
          if (currentQuadrant === 0) direction = 'east';
          else if (currentQuadrant === 1) direction = 'south_from_q1';
          else if (currentQuadrant === 2) direction = 'west_from_q2';
          else direction = 'north';
        } else {
          if (currentQuadrant === 0) direction = 'south';
          else if (currentQuadrant === 1) direction = 'west';
          else if (currentQuadrant === 2) direction = 'north_from_q2';
          else direction = 'east_from_q3';
        }
        
        isAnimating = false; // performKipp setzt isAnimating selbst
        await performKipp(direction, 700);
        advanceTopFace();
        
        // Kurze Pause zwischen Kipps
        if (i < steps - 1) {
          await sleep(300);
        }
      }
      
      kippCount = steps;
      isAnimating = false;
      
      // Trefferwertung nach kurzem Moment
      await sleep(200);
      checkKippzielTap();
    }

    // =========================
    // CW/CCW Richtung
    let kippDirection = 'cw';
    
    // Richtungsklassifizierung f√ºr Swipe-Kipping
    const CW_DIRS = new Set(['east', 'south_from_q1', 'west_from_q2', 'north']);
    const CCW_DIRS = new Set(['south', 'west', 'north_from_q2', 'east_from_q3']);
    let lockedKippDir = null; // null, 'cw', 'ccw'
    let currentDragDir = null;
    
    const cwBtn = document.getElementById('cwBtn');
    const ccwBtn = document.getElementById('ccwBtn');

    function updateRichtungButtons() {
      if (kippDirection === 'cw') {
        cwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        cwBtn.style.color = '#c0b870';
        cwBtn.style.borderColor = '#d4b48c';
        cwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        ccwBtn.style.color = '#c0b8a8';
        ccwBtn.style.borderColor = '#808080';
        ccwBtn.style.boxShadow = '';
      } else {
        ccwBtn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        ccwBtn.style.color = '#c0b870';
        ccwBtn.style.borderColor = '#d4b48c';
        ccwBtn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';
        cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
        cwBtn.style.color = '#c0b8a8';
        cwBtn.style.borderColor = '#808080';
        cwBtn.style.boxShadow = '';
      }
    }
    // CW/CCW werden durch triggerKipp weiter unten gehandelt

    // =========================
    // Zwei-Schritt Ablauf: erst Zahl w√§hlen, dann Richtung
    // =========================
    let selectedAnzahl = null;

    function setButtonsDisabled(disabled) {
      document.querySelectorAll('.kippBtn').forEach(btn => {
        btn.disabled = disabled;
        btn.classList.remove('pulsing');
        if (!disabled) {
          btn.style.background = btn.id === 'cwBtn' || btn.id === 'ccwBtn'
            ? 'linear-gradient(180deg,#404040 0%,#303030 100%)'
            : 'linear-gradient(180deg,#606060 0%,#404040 100%)';
          btn.style.color = '#c0b8a8';
          btn.style.borderColor = '#808080';
          btn.style.boxShadow = '';
        }
      });
      if (!disabled) startZahlWarten();
    }

    function pulseZahlenButtons(on) {
      document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
        if (on) btn.classList.add('pulsing');
        else btn.classList.remove('pulsing');
      });
    }
    function pulseRichtungButtons(on) {
      if (on) { cwBtn.classList.add('pulsing'); ccwBtn.classList.add('pulsing'); }
      else    { cwBtn.classList.remove('pulsing'); ccwBtn.classList.remove('pulsing'); }
    }

    function startZahlWarten() {
      selectedAnzahl = null;
      pulseZahlenButtons(true);
      pulseRichtungButtons(false);
      // Richtungsbuttons neutral (keine Hervorhebuung)
      cwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      cwBtn.style.color = '#c0b8a8';
      cwBtn.style.borderColor = '#808080';
      cwBtn.style.boxShadow = '';
      ccwBtn.style.background = 'linear-gradient(180deg,#404040 0%,#303030 100%)';
      ccwBtn.style.color = '#c0b8a8';
      ccwBtn.style.borderColor = '#808080';
      ccwBtn.style.boxShadow = '';
    }

    function startRichtungWarten() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(true);
    }

    function stopAllenPulse() {
      pulseZahlenButtons(false);
      pulseRichtungButtons(false);
    }

    // Zahl-Buttons: nur Zahl speichern, kein Kipp
    document.querySelectorAll('.kippBtn[data-anzahl]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gamePhase !== 'spielen') return;
        if (selectedAnzahl !== null) return; // schon eine Zahl gew√§hlt

        selectedAnzahl = parseInt(btn.dataset.anzahl);

        // Gew√§hlte Zahl hervorheben
        btn.style.background = 'linear-gradient(180deg,#4a3e28 0%,#3a2e1c 100%)';
        btn.style.color = '#c0b870';
        btn.style.borderColor = '#d4b48c';
        btn.style.boxShadow = '0 0 8px rgba(212,180,140,0.6), 0 0 20px rgba(212,180,140,0.35)';

        startRichtungWarten();
      });
    });

    // CW/CCW: wenn Zahl schon gew√§hlt ‚Üí Kipp starten
    async function triggerKipp(direction) {
      if (gamePhase !== 'spielen') return;
      if (selectedAnzahl === null) return; // noch keine Zahl ‚Üí nur Richtung anzeigen

      const anzahl = selectedAnzahl;
      stopAllenPulse();
      setButtonsDisabled(true);

      kippDirection = direction;
      updateRichtungButtons();

      // Zielkreis ausblenden w√§hrend Kipp-Animation
      document.getElementById('kippTarget').style.display = 'none';

      // K√§rtchen auf Original zur√ºcksetzen - Image neu zeichnen
      const card = gameCards[activeCardIdx];
      const img = colorTargetImages[card.color.name];
      
      card.ctx.clearRect(0, 0, 85, 170);
      card.ctx.drawImage(img, 0, 0, 85, 170);
      
      const displayText = card.zahl + ((card.zahl === 6 || card.zahl === 9) ? '.' : '');
      card.ctx.fillStyle = '#2a1810';
      card.ctx.font = 'bold 56px Arial';
      card.ctx.textAlign = 'center';
      card.ctx.textBaseline = 'middle';
      card.ctx.fillText(displayText, 42, 42);
      card.texture.needsUpdate = true;
      card.mesh.scale.set(1, 1, 1);
      card.mesh.material.opacity = 1.0;

      await runKippSequence(anzahl);

      // Treffer-Pr√ºfung
      const treffer = checkTreffer();
      if (treffer) {
        bereitsGetroffen.add(card.zahl + '_' + card.color.name);
        animateTreffer();
      } else {
        animateNichtTreffer();
      }
    }

    cwBtn.addEventListener('click', () => triggerKipp('cw'));
    ccwBtn.addEventListener('click', () => triggerKipp('ccw'));

    // Animation loop
    function renderLoop() {
      requestAnimationFrame(renderLoop);
      
      // Puls-Animation f√ºr verdecktes Kippziel (nur wenn nicht aufgedeckt)
      if (verdecktesMesh.visible && !verdecktesMesh.userData.revealed) {
        const t = (Date.now() % 1500) / 1500 * Math.PI * 2;
        const pulse = (Math.sin(t) + 1) / 2; // 0 bis 1
        const s = 1 + 0.08 * pulse;
        verdecktesMesh.scale.set(s, s, s);
        verdecktesMat.opacity = 1 - 0.4 * pulse;
      }
      
      renderer.render(scene, camera);
    }

    renderLoop();
  </script>
</body>
</html>
